\pagebreak
\section{G2: Embed Maintainability}
\label{sec:g2-embed-maintainability}

This section presents G2, which focuses on embedding maintainability as an architectural property of modular monolith applications. In this dissertation, maintainability is framed economically as a bounded cost of change: the architecture constrains the expected effort, risk, and coordination required to modify the system as it evolves. Rather than treating maintainability as an indirect outcome of refactoring or developer discipline, G2 operationalizes it through explicit design constraints, stable interaction contracts, and continuous detection of architectural drift.

G2 builds directly on G1. While G1 enforces the existence of explicit modular boundaries, G2 ensures that those boundaries remain effective over time. Together, these guidelines prevent the gradual erosion that often causes traditional monoliths to regress into tightly coupled systems with monolithic change dynamics.

\subsection*{Intent and Rationale}
Empirical studies consistently show that the primary driver of maintainability degradation in monolithic systems is not system size, but the accumulation of hidden coupling, ambiguous dependency direction, and architectural drift over time \cite{gravanis2021dont,blinowski2022monolithic}. As systems evolve, convenience-driven shortcuts such as deep imports, shared utilities, and implicit wiring gradually increase the blast radius of change and raise coordination costs.

This dissertation treats maintainability as a preventive architectural concern. G2 preserves bounded cost of change by constraining how modules interact, how dependencies are introduced, and how responsibilities are distributed. The guideline prioritizes change locality, stable contracts, and controlled dependency growth over short-term reuse. These properties ensure that most changes remain confined to a single bounded context and that the effort required to evolve the system scales sublinearly with its size.

G2 extends G1 from boundary correctness to boundary sustainability. While G1 makes dependencies explicit and verifiable, G2 ensures that those dependencies remain limited in scope, stable under evolution, measurable through specific metrics and economically manageable as the system grows \cite{arya2024beyond,berry2024isItWorth}.

\pagebreak
\subsection*{Conceptual Overview}
Maintainability is embedded by designing modules so that change remains local and predictable:
\begin{itemize}[noitemsep,topsep=2pt]
  \item Each bounded context exposes a narrow and intentional public surface that represents stable capabilities rather than internal structure.
  \item Cross-module interaction occurs exclusively through explicit contracts.
  \item Dependency direction reflects responsibility and information flow, reducing the risk of cycles and cascading change.
  \item Architectural drift is detected early through executable and observable structural signals.
\end{itemize}

\subsection*{Applicability Conditions and Scope}
G2 applies to systems organized as modular monoliths, where multiple bounded context modules coexist within a single codebase and are expected to evolve continuously. The guideline assumes that:
\begin{itemize}[noitemsep,topsep=2pt]
  \item Module boundaries are explicitly defined and at least partially enforced, as established by G1.
  \item Each module has clear ownership and a well-defined responsibility.
  \item Architectural drift is a realistic risk during ongoing feature development.
\end{itemize}

G2 does not prescribe specific frameworks, build tools, or CI pipelines. Its scope is limited to metrics definition, design-time and code-level practices that directly influence long-term changeability.

\subsection*{Objectives}
\begin{itemize}[noitemsep,topsep=2pt]
  \item Bound the cost of change by limiting change propagation across modules.
  \item Stabilize dependency direction through disciplined layering and contract first boundaries.
  \item Constrain the growth of module public surfaces.
  \item Detect architectural drift before it becomes structurally expensive to reverse.
  \item Preserve the option for incremental refactoring and future decomposition.
\end{itemize}

\pagebreak
\subsection*{Key Principles}
\begin{itemize}[noitemsep,topsep=2pt]
  \item \emph{Encapsulation before reuse:} Cross-module reuse of internal code is treated as a maintainability risk unless mediated through an explicit contract.
  \item \emph{Contract over structure:} Modules depend on declared interfaces or events, not on internal implementation details.
  \item \emph{Unidirectional dependency flow:} Dependency direction reflects responsibility and information flow, and cycles are considered maintainability violations.
  \item \emph{Change locality:} Most changes should be implementable within a single module.
  \item \emph{Evolution over speculation:} Abstractions are introduced to support observed change, not anticipated reuse.
\end{itemize}

\subsection*{Implementation Mechanisms}
G2 is implemented through established software engineering practices rather than framework-specific mechanisms:
\begin{itemize}[noitemsep,topsep=2pt]
  \item \emph{Layered internal structure:} Within each bounded context, code is organized into domain, application, and infrastructure concerns, ensuring that business rules remain insulated from volatile technical details.
  \item \emph{Explicit module entrypoints:} Each module exposes a single public surface that defines its externally visible capabilities.
  \item \emph{Contract-oriented collaboration:} Cross-module interaction occurs through synchronous interfaces or published domain events.
  \item \emph{Centralized composition:} Wiring between modules is visible and auditable, preventing implicit coupling.
  \item \emph{Governed exceptions:} Deviations from dependency or layering rules require explicit justification.
\end{itemize}

\subsection*{Common Failure Modes and Anti-Patterns}
The following failure modes are frequently observed in modular monoliths that lack explicit maintainability discipline. Each anti-pattern increases the cost of change by expanding the blast radius of modifications, weakening ownership boundaries, or introducing hidden coupling. For each anti-pattern, G2 defines one or more metrics that make the degradation observable and verifiable.

\begin{itemize}[noitemsep,topsep=2pt]
  \item \emph{Cross-Module Internal Reuse:} Reusing internal classes or utilities from another module instead of interacting through a declared public API tightly couples the consumer to the provider’s internal structure. Internal refactoring then forces coordinated changes across modules, undermining independent evolution. This anti-pattern is primarily detected through an increase in encapsulation leakage count ($C_{\mathrm{leak}}$) and a reduction in the API-only dependency ratio ($\rho_{\mathrm{api}}$).

  \item \emph{Implicit Dependency Introduction:} Dependencies introduced through configuration, dependency injection wiring, or reflection without explicit declaration bypass architectural review. Over time, they erode the reliability of dependency models and increase the effort required to assess change impact. This failure mode is reflected by an increase in undeclared dependency references ($C_{\mathrm{undecl}}$) and by reduced module isolation test pass rates ($P_{\mathrm{iso}}$).

  \item \emph{Bidirectional or Cyclic Dependencies:} Allowing modules to depend on each other directly or indirectly introduces cycles that prevent independent evolution. Cycles increase cognitive load and coordination cost and are expensive to remove once established. This anti-pattern is detected through forbidden dependency references ($C_{\mathrm{forbid}}$) and explicit cycle analysis of the module dependency graph.

  \item \emph{Overloaded Module APIs:} Uncontrolled growth of a module’s public surface leads to unstable interfaces and defensive design. Refactoring becomes increasingly risky, and internal structure gradually freezes. This failure mode is indicated by a declining API-only dependency ratio ($\rho_{\mathrm{api}}$) and sustained growth of the module’s public API surface over time.

  \item \emph{Feature-Centric Coupling Across Modules:} When features span multiple modules without clear ownership, features rather than modules become the primary unit of change. This pattern increases coordination cost and dilutes accountability. It is weakly visible in static dependencies but becomes evident through repeated cross-module co-changes and elevated architectural drift incidents.
\end{itemize}

These anti-patterns emerge when local convenience is prioritized over long-term change cost. G2 addresses them by enforcing explicit contracts, constraining dependency growth, and making structural erosion observable before it becomes irreversible.

\subsection*{Metrics and Verification}
Maintainability in G2 is assessed through a set of explicit, measurable structural signals that capture boundary erosion, hidden coupling, and architectural drift over time. These metrics operationalize maintainability as a bounded cost of change by making the growth of coupling, dependency instability, and encapsulation violations observable and verifiable.

G2 builds directly on the enforcement model introduced in G1. While G1 establishes the correctness of modular boundaries, G2 uses quantitative signals to assess whether those boundaries remain effective as the system evolves. The quality measurement baseline derived from G1 (Section~\ref{sec:g1-enforce-modular-boundaries}) is reused here as the foundation for maintainability verification.

\begin{itemize}[noitemsep,topsep=2pt]
  \item \emph{Notation:} Let $M$ be the set of bounded-context modules. Let $R$ be the multiset of observed cross-module references, including static imports, dependency injection wiring, and event handlers. Let $D \subseteq M \times M$ be the set of declared allowed dependencies (\emph{requires}) and $F \subseteq M \times M$ be the set of explicitly forbidden dependencies (\emph{forbids}).
\end{itemize}

\begin{itemize}[noitemsep,topsep=2pt]
  \item \emph{Structural maintainability metrics:} The following metrics make boundary erosion and architectural drift observable using structural signals derived from cross-module references.
\end{itemize}

\begin{itemize}[noitemsep,topsep=2pt]
  \item \emph{Undeclared Dependency Reference Count:}
  \[
    C_{\mathrm{undecl}} = \left| \{ (A,B) \in R \mid (A,B) \notin D \} \right|
  \]
  \emph{Maintainability meaning:} measures hidden coupling introduced without architectural review. \\
  \emph{Verification intent:} ensure all cross-module dependencies are explicit and reviewable.\\

  \item \emph{Forbidden Dependency Reference Count:}
  \[
    C_{\mathrm{forbid}} = \left| \{ (A,B) \in R \mid (A,B) \in F \} \right|
  \]
  \emph{Maintainability meaning:} detects structurally disallowed coupling that violates architectural constraints. \\
  \emph{Verification intent:} preserve strict isolation where required and prevent dependency cycles.\\

  \item \emph{API-Only Dependency Ratio:}
  Let $R_{\mathrm{api}} \subseteq R$ be references targeting only the provider module’s public surface:
  \[
    \rho_{\mathrm{api}} = \frac{|R_{\mathrm{api}}|}{|R|}
  \]
  \emph{Maintainability meaning:} indicates whether dependencies are routed through stable contracts rather than internal structures. \\
  \emph{Verification intent:} constrain change propagation and stabilize interaction surfaces.\\

  \item \emph{Encapsulation Leakage Count:}
  Let $R_{\mathrm{internal}} \subseteq R$ be references to internal packages or non-exported symbols:
  \[
    C_{\mathrm{leak}} = |R_{\mathrm{internal}}|
  \]
  \emph{Maintainability meaning:} quantifies boundary bypass that increases blast radius and refactoring risk. \\
  \emph{Verification intent:} enforce information hiding at the module boundary.

  \item \emph{Module Isolation Test Pass Rate:}
  Let $T_{\mathrm{iso}}$ be the set of module isolation tests:
  \[
    P_{\mathrm{iso}} = \frac{|T_{\mathrm{pass}}|}{|T_{\mathrm{iso}}|}
  \]
  \emph{Maintainability meaning:} detects implicit coupling not visible through static analysis alone. \\
  \emph{Verification intent:} ensure modules can execute using only their declared dependencies.

  \item \emph{Event Subscription Boundary Violations (when events are used):}
  Let $H$ be the set of event handlers in module $A$ consuming events from module $B$:
  \[
    C_{\mathrm{event}} = \left| \{ (A,B) \in H \mid (A,B) \notin D \} \right|
  \]
  \emph{Maintainability meaning:} captures undeclared coupling introduced through event-driven integration. \\
  \emph{Verification intent:} keep asynchronous collaboration explicit and auditable.

  \item \emph{Boundary Bypass Surface Count (optional):}
  Let $S_{\mathrm{bypass}}$ be occurrences of bypass mechanisms within cross-module interaction paths:
  \[
    C_{\mathrm{bypass}} = |S_{\mathrm{bypass}}|
  \]
  \emph{Maintainability meaning:} indicates reliance on mechanisms that evade static boundary enforcement. \\
  \emph{Verification intent:} identify high-risk interaction paths that undermine architectural guarantees.
\end{itemize}

\begin{itemize}[noitemsep,topsep=2pt]
  \item \emph{Supplementary maintainability metrics:} Some maintainability risks emerge over time and are not fully captured by static dependency analysis alone. G2 therefore defines the following supplementary metrics to detect API inflation and feature-centric coupling.
\end{itemize}

\begin{itemize}[noitemsep,topsep=2pt]
  \item \emph{Public API Surface Growth Rate:}
  \[
    G_{\mathrm{api}}(m) = \frac{|API_m(t)| - |API_m(t - \Delta t)|}{\Delta t}
  \]
  \emph{Maintainability meaning:} sustained growth indicates increasing downstream obligations and reduced refactoring freedom. \\
  \emph{Action:} consolidate contracts, remove accidental exposure, or split responsibilities.

  \item \emph{Change Coupling Index (optional):}
  Let $C(A,B)$ denote the number of commits where modules $A$ and $B$ change together within a defined time window:
  \[
    CCI = \frac{\sum_{A \neq B} C(A,B)}{\sum_{A} C(A)}
  \]
  \emph{Maintainability meaning:} high values indicate feature-centric coupling and blurred ownership boundaries. \\
  \emph{Action:} reassign responsibilities, introduce clearer module contracts, or refactor feature orchestration logic.
\end{itemize}

\begin{itemize}[noitemsep,topsep=2pt]
  \item \emph{Verification strategy and maintainability interpretation:} In G2, these metrics are treated as longitudinal signals of architectural health rather than isolated quality indicators. Increases in $C_{\mathrm{undecl}}$, $C_{\mathrm{leak}}$, or $C_{\mathrm{forbid}}$ indicate growing hidden coupling and rising cost of change. A declining $\rho_{\mathrm{api}}$ signals unstable dependency surfaces, while reductions in $P_{\mathrm{iso}}$ reveal erosion of modular isolation.

  By tracking these metrics over time and enforcing thresholds where appropriate, G2 enables early detection of architectural drift and supports timely refactoring while corrective actions remain localized and economically viable. The primary objective is not to eliminate change, but to ensure that its cost remains bounded as the system evolves.
\end{itemize}

\subsection*{Documentation Guidelines}
\begin{itemize}[noitemsep,topsep=2pt]
  \item \emph{Dependency Direction Map:}
  Maintain a visual or textual map of the allowed dependency direction between modules. This map complements G1's module descriptor by making the intended information flow explicit and reviewable during architectural discussions.

  \item \emph{Contract Change Log:}
  Whenever a module's public surface changes (new handler, modified event schema, deprecated endpoint), record the change with version metadata. This log supports backward-compatibility analysis and informs downstream consumers of evolving contracts.

  \item \emph{Architectural Drift Incidents:}
  When a metric threshold is crossed (e.g., $C_{\mathrm{undecl}} > 0$ or $\rho_{\mathrm{api}}$ drops below target), record the incident, root cause, and resolution. This creates a traceable history of maintainability interventions.
\end{itemize}

\subsection*{Tooling Capabilities Checklist}
Any open-source or proprietary tool used to support maintainability should address:
\begin{itemize}[noitemsep,topsep=2pt]
  \item \emph{Dependency Graph Visualization:} Generate and display the module dependency graph, highlighting cycles, undeclared dependencies, and forbidden references.
  \item \emph{API Surface Analysis:} Track the size and growth rate of each module's public surface over time ($G_{\mathrm{api}}$).
  \item \emph{Change Coupling Detection:} Identify modules that frequently change together across commits ($CCI$), signaling feature-centric coupling or blurred ownership.
  \item \emph{Longitudinal Metric Tracking:} Store and visualize G2 metrics over time, enabling trend analysis and early detection of architectural drift.
  \item \emph{Contract Compatibility Checking:} Verify that changes to a module's public surface do not break downstream consumers, ideally integrated into the CI pipeline.
\end{itemize}

\subsection*{Reference Implementation}
G2's maintainability principles are demonstrated through the same Tiny Store reference implementation used in G1. The relevant structural artifacts are:
\begin{itemize}[noitemsep,topsep=2pt]
  \item \texttt{libs/modules/*/src/index.ts} --- Module entrypoints that define the public surface for each bounded context
  \item \texttt{libs/shared/testing/src/module-boundary.spec.ts} --- Boundary verification tests that enforce dependency direction and detect encapsulation leakage
  \item \texttt{apps/api/src/app/lib/register-listeners.ts} --- Centralized event wiring that makes cross-module collaboration auditable
  \item \texttt{nx.json} and \texttt{.eslintrc.json} --- Nx workspace configuration with \texttt{@nx/enforce-module-boundaries} rules
\end{itemize}

\subsection*{Literature Support Commentary}
Although maintainability is a central topic in software engineering, much of the literature treats it either as an abstract principle or as a collection of localized code quality metrics. Recent empirical studies and systematic reviews emphasize that maintainability improvements in modular monoliths are primarily driven by boundary discipline and dependency management rather than deployment decomposition alone~\cite{gravanis2021dont,berry2024isItWorth,blinowski2022monolithic}.

Evolutionary architecture research further argues that architectural properties such as maintainability must be preserved through objective, executable constraints rather than informal guidance~\cite{FordParsons2017}. The concept of \emph{architectural fitness functions}, as popularized by ThoughtWorks~\cite{thoughtworks2017fitnessfunction}, operationalizes this perspective by defining automated checks that continuously verify whether the architecture satisfies its intended properties. G2 synthesizes these insights by framing maintainability as bounded cost of change and by providing concrete design mechanisms and measurable signals grounded in the boundary enforcement model established by G1.

%% ============================================================
%% G2 APPLIED
%% ============================================================
\pagebreak
\subsection*{G2 Applied: Maintainability in the Tiny Store}
\label{sec:g2-applied}

This section operationalizes G2 using the same Tiny Store reference implementation introduced in G1 (Section~\ref{sec:g1-demo-tiny-store}). While G1 demonstrated how to \emph{establish} modular boundaries, G2 shows how to keep those boundaries \emph{effective over time} by examining layered internal structure, tracing dependency direction, measuring encapsulation health, and detecting architectural drift through concrete metrics. The tutorial connects each G2 principle to an observable artifact in the codebase, and the exercise walkthrough introduces controlled maintainability violations so the reader can witness metric degradation firsthand.

\subsection*{Reader Map}
The tutorial below is designed to be completed in a single sitting (approximately 30 minutes). It assumes the repository baseline established in G1 is passing. You will first inspect how maintainability is structurally embedded in the codebase, then learn to compute the G2 metrics from real dependency data, and finally run exercises that degrade specific metrics by introducing common maintainability anti-patterns. Each exercise states what you change, what you run, and the expected signal.

\pagebreak
\subsection*{Tutorial: Step-by-Step Application}

\subsubsection*{Step 1: Examine the Layered Internal Structure}
Within each bounded context, Tiny Store organizes code into three cohesive layers that mirror the separation of concerns prescribed by G2:

\begin{lstlisting}[language=bash,caption={Internal structure of the Orders module},label={lst:g2-orders-tree}]
libs/modules/orders/src/
  domain/
    entities/        # Order aggregate, value objects
    enums/           # OrderStatus
    events/          # OrderPlaced, OrderConfirmed, ...
    repositories/    # OrderRepository (persistence port)
    value-objects/   # CustomerId, OrderItem
  features/
    place-order/     # handler.ts, service.ts, dto.ts
    cancel-order/
    get-order/
    list-orders/
  listeners/
    inventory-reserved.listener.ts
    inventory-reservation-failed.listener.ts
    payment-processed.listener.ts
    payment-failed.listener.ts
    shipment-created.listener.ts
  index.ts           # Public API surface
\end{lstlisting}

The dependency direction within the module is strictly inward: \texttt{listeners/} and \texttt{features/} depend on \texttt{domain/}, but \texttt{domain/} depends on neither. This layering insulates business rules from application-level orchestration and event-handling concerns. For example, the \texttt{InventoryReservedListener} imports from \texttt{domain/repositories} and \texttt{domain/events} within its own module, but never reaches into another module's internals:

\begin{lstlisting}[language=TypeScript,caption={Listener depending only on local domain (orders/src/listeners/inventory-reserved.listener.ts)},label={lst:g2-listener-deps}]
import { DomainEvent, EventBus } from '@tiny-store/shared-infrastructure';
import { OrderRepository } from '../domain/repositories/order.repository';
import {
  createOrderConfirmedEvent,
  OrderConfirmedPayload,
} from '../domain/events/order-confirmed.event';

export class InventoryReservedListener {
  private orderRepository: OrderRepository;
  private eventBus: EventBus;

  constructor(dataSource: DataSource) {
    this.orderRepository = new OrderRepository(dataSource);
    this.eventBus = EventBus.getInstance();
  }

  async handle(event: DomainEvent): Promise<void> {
    const { orderId } = event.payload;
    const order = await this.orderRepository.findById(orderId);
    if (!order) return;
    order.confirm();
    await this.orderRepository.save(order);

    const confirmedEvent = createOrderConfirmedEvent(
      order.id, { orderId: order.id });
    await this.eventBus.publish(confirmedEvent);
  }
}
\end{lstlisting}

This structure ensures that the \emph{domain layer} remains the stable core of the module. Features and listeners can change independently as long as they honor the domain contracts, which is the practical manifestation of G2's \emph{change locality} principle.

\subsubsection*{Step 2: Trace Dependency Direction}
G2 requires that dependency direction reflects responsibility and information flow. In Tiny Store, the Orders module depends on \texttt{shared-domain} and \texttt{shared-infrastructure}, but never imports from \texttt{@tiny-store/modules-inventory} or any other bounded context. Cross-module collaboration flows exclusively through domain events.

Inspect the import statements in any Orders source file. All external imports resolve to shared libraries:

\begin{lstlisting}[language=TypeScript,caption={External dependencies in Order aggregate (orders/src/domain/entities/order.ts)},label={lst:g2-order-deps}]
import {
  AggregateRoot,
  BusinessRuleViolationError,
  Money,
  Address,
} from '@tiny-store/shared-domain';
\end{lstlisting}

No file under \texttt{libs/modules/orders/} contains an import from \texttt{@tiny-store/modules-inventory}, \texttt{@tiny-store/modules-payments}, or \texttt{@tiny-store/modules-shipments}. This is verifiable mechanically:

\begin{lstlisting}[language=bash,caption={Verify no cross-module imports exist in Orders},label={lst:g2-grep-cross}]
grep -r "@tiny-store/modules-" libs/modules/orders/src/ \
  --include="*.ts" | grep -v node_modules
# Expected: no output (zero cross-module imports)
\end{lstlisting}

The same holds for Inventory, Payments, and Shipments. Each module is a self-contained unit whose only outward dependencies point to shared infrastructure. This unidirectional flow is what makes independent evolution possible: refactoring the Order aggregate's internal structure requires no coordination with the Inventory team.

\subsubsection*{Step 3: Contract-Oriented Collaboration via the Composition Root}
Cross-module wiring in Tiny Store is centralized in \texttt{register-listeners.ts}, the composition root introduced in G1. From a G2 perspective, this file is the \emph{auditable map of cross-module coupling}. Every event subscription is visible in one place, making it straightforward to answer questions like ``Who reacts when an order is placed?'' or ``What happens after payment succeeds?''

\begin{lstlisting}[language=TypeScript,caption={Cross-module wiring excerpt (register-listeners.ts)},label={lst:g2-register-excerpt}]
// Inventory reacts to order lifecycle events
const orderPlacedListener = new OrderPlacedListener(dataSource);
eventBus.subscribe('OrderPlaced',
  (event) => orderPlacedListener.handle(event));

const orderCancelledListener = new OrderCancelledListener(dataSource);
eventBus.subscribe('OrderCancelled',
  (event) => orderCancelledListener.handle(event));

// Orders reacts to inventory decisions
const inventoryReservedListener =
  new InventoryReservedListener(dataSource);
eventBus.subscribe('InventoryReserved',
  (event) => inventoryReservedListener.handle(event));
\end{lstlisting}

This centralization serves two G2 objectives. First, it makes dependency direction \emph{reviewable}: a new subscription is a code change in the composition root, subject to review. Second, it prevents \emph{implicit coupling}: no module can silently subscribe to another module's events from within its own code. The cross-module dependency graph is exactly what \texttt{register-listeners.ts} declares---nothing more, nothing less.

\subsubsection*{Step 4: API Surface Control}
G2 treats the module entrypoint (\texttt{index.ts}) as the enforceable boundary between public contract and internal implementation. Compare what Orders exports with what it contains:

\begin{lstlisting}[language=TypeScript,caption={Orders public surface (libs/modules/orders/src/index.ts)},label={lst:g2-orders-index}]
// Public API -- Handlers
export * from './features/place-order/handler';
export * from './features/cancel-order/handler';
export * from './features/get-order/handler';
export * from './features/list-orders/handler';

// Public API -- Listeners
export * from './listeners/inventory-reserved.listener';
export * from './listeners/inventory-reservation-failed.listener';
export * from './listeners/payment-processed.listener';
export * from './listeners/payment-failed.listener';
export * from './listeners/shipment-created.listener';
\end{lstlisting}

The module contains 14+ internal files (entities, repositories, value objects, enums, services, DTOs), yet exports only 9 symbols: 4 handlers and 5 listeners. Everything else---\texttt{Order}, \texttt{OrderRepository}, \texttt{OrderItem}, \texttt{CustomerId}, \texttt{PlaceOrderService}---remains internal. The boundary test suite confirms this:

\begin{lstlisting}[language=TypeScript,caption={Boundary test verifying encapsulation (module-boundary.spec.ts)},label={lst:g2-boundary-encap}]
it('should NOT allow access to Order entities', async () => {
  const orders = await import('@tiny-store/modules-orders');
  expect((orders as any).Order).toBeUndefined();
  expect((orders as any).OrderEntity).toBeUndefined();
});

it('should NOT expose internal services directly', async () => {
  const orders = await import('@tiny-store/modules-orders');
  expect((orders as any).PlaceOrderService).toBeUndefined();
  expect((orders as any).OrderDomainService).toBeUndefined();
});
\end{lstlisting}

This controlled surface is how G2 bounds the cost of change: downstream consumers depend on \emph{what the module does} (handlers, listeners), not on \emph{how it does it} (entities, repositories, services).

\subsubsection*{Step 5: Computing Maintainability Metrics}
G2 defines several metrics that make architectural health observable. Using Tiny Store's current state, we can compute the baseline values:

\begin{itemize}[noitemsep,topsep=2pt]
  \item $C_{\mathrm{undecl}}$: Run \texttt{grep -r "@tiny-store/modules-" libs/modules/orders/src/} to find cross-module references. In the clean baseline, this returns zero results, so $C_{\mathrm{undecl}} = 0$.
  \item $C_{\mathrm{leak}}$: The boundary test suite checks that internal symbols (\texttt{Order}, \texttt{OrderRepository}, \texttt{Product}, etc.) are not exported. All assertions pass, so $C_{\mathrm{leak}} = 0$.
  \item $\rho_{\mathrm{api}}$: All cross-module references in \texttt{register-listeners.ts} target public entrypoints (\texttt{@tiny-store/modules-*}), never deep paths. With $|R| = |R_{\mathrm{api}}|$, we get $\rho_{\mathrm{api}} = 1.0$.
  \item $C_{\mathrm{forbid}}$: No module imports another module directly, so $C_{\mathrm{forbid}} = 0$.
  \item $P_{\mathrm{iso}}$: All boundary tests pass, so $P_{\mathrm{iso}} = 1.0$.
\end{itemize}

\begin{lstlisting}[language=bash,caption={Baseline metric verification},label={lst:g2-baseline-metrics}]
# C_undecl: cross-module imports inside any module
grep -r "@tiny-store/modules-" libs/modules/*/src/ \
  --include="*.ts" | wc -l
# Expected: 0

# C_leak + rho_api: boundary tests cover both
npm run test:boundary
# Expected: all pass

# C_forbid: no forbidden imports
npm run test:boundary
# Expected: all pass, no forbidden reference warnings
\end{lstlisting}

\subsubsection*{Step 6: Detecting Architectural Drift}
Architectural drift occurs when small, individually harmless changes accumulate into structural degradation. The metrics above provide early warning. For example, if a developer adds a convenience import in a single file:

\begin{lstlisting}[language=TypeScript,caption={A single convenience import (architectural drift seed)},label={lst:g2-drift-seed}]
// In libs/modules/orders/src/features/place-order/service.ts
import { Product } from '@tiny-store/modules-inventory/src/domain/entities/product';
\end{lstlisting}

This single line shifts $C_{\mathrm{undecl}}$ from 0 to 1 and $\rho_{\mathrm{api}}$ below 1.0. If left undetected, similar shortcuts in other files would compound: $C_{\mathrm{undecl}}$ grows linearly, $\rho_{\mathrm{api}}$ declines, and eventually the ``modular'' monolith behaves like a coupled monolith where changing Inventory's \texttt{Product} entity forces coordinated changes in Orders. The boundary test suite catches this immediately, transforming what would be invisible drift into an actionable signal.

\pagebreak
\subsection*{Exercise Walkthrough: Controlled Maintainability Violations}
The exercises below intentionally degrade specific G2 metrics to demonstrate that the enforcement mechanisms are active and the metrics are observable. Each exercise introduces a single anti-pattern from the failure modes described earlier, runs the verification suite, and reports the expected metric change.

\subsubsection*{Exercise 0: Establish Maintainability Baseline}
Confirm that all G2 metrics are at their healthy values before introducing violations.

\begin{lstlisting}[language=bash,caption={Establish G2 baseline},label={lst:g2-ex0}]
npm run test:boundary
npm run test:integration

# Baseline values:
# C_undecl = 0, C_leak = 0, C_forbid = 0
# rho_api = 1.0, P_iso = 1.0
\end{lstlisting}

\subsubsection*{Exercise 1: Convenience Re-export Chain ($\rho_{\mathrm{api}}\downarrow$)}
Introduce a ``dependency laundering'' layer: a shared barrel file that re-exports handlers from multiple modules, allowing consumers to bypass the actual module API surface. G1's boundary checks see only a legal import from \texttt{@tiny-store/shared-infrastructure}, but the architectural intent---that each module is the \emph{sole gateway} to its own capabilities---is silently violated.

\emph{What you change:} Create \texttt{libs/shared/infrastructure/src/convenience.ts} with re-exports from two peer modules:

\begin{lstlisting}[language=TypeScript,caption={Anti-pattern: convenience re-export barrel},label={lst:g2-ex1-violation}]
// libs/shared/infrastructure/src/convenience.ts
// "Convenience" re-exports -- every symbol here is public,
// but routing through shared hides the real dependency.
export { PlaceOrderHandler } from '@tiny-store/modules-orders';
export { ReserveStockHandler } from '@tiny-store/modules-inventory';
\end{lstlisting}

Then, in a new Shipments feature, import from the convenience barrel instead of the owning module:

\begin{lstlisting}[language=TypeScript,caption={Consumer uses the convenience barrel},label={lst:g2-ex1-consumer}]
// libs/modules/shipments/src/features/create-shipment/service.ts
// DRIFT: importing Orders capability via shared, not via Orders
import { PlaceOrderHandler }
  from '@tiny-store/shared-infrastructure/convenience';
\end{lstlisting}

\emph{What you run:}
\begin{lstlisting}[language=bash,caption={Run enforcement after Exercise 1},label={lst:g2-ex1-run}]
npm run test:boundary          # G1 checks
npm run metrics:maintainability # G2 metrics
\end{lstlisting}

\emph{Expected signal:} G1 boundary checks: \textbf{pass} \checkmark{} --- Shipments imports from \texttt{shared-infrastructure}, which is an allowed dependency. No $C_{\mathrm{leak}}$, $C_{\mathrm{undecl}}$, or $C_{\mathrm{forbid}}$ violations appear. However, the G2 metric $\rho_{\mathrm{api}}$ drops below 1.0: Shipments consumes an Orders capability without a direct dependency edge to \texttt{modules-orders}. The Nx dependency graph shows Shipments $\rightarrow$ shared-infrastructure but \emph{not} Shipments $\rightarrow$ Orders, masking the true coupling topology.

\emph{Fix:} Delete the convenience barrel. Shipments should import \texttt{PlaceOrderHandler} directly from \texttt{@tiny-store/modules-orders}. If the import is needed, it should be explicit---making the dependency visible in the graph and countable by $\rho_{\mathrm{api}}$.

\emph{G2 insight:} A boundary can be \emph{correct} (G1) yet \emph{opaque}---convenience re-exports erode dependency traceability over time, turning ``shared'' libraries into coupling laundromats that $\rho_{\mathrm{api}}$ is designed to detect.

\subsubsection*{Exercise 2: Feature-Centric Co-Change Pattern ($\mathrm{CCI}\uparrow$)}
Introduce a cross-cutting business feature---discounts---that requires simultaneous changes to Orders and Payments. Both modules remain structurally independent (no shared imports, no boundary violations), yet every commit that touches one also touches the other. This is invisible to G1 but measurable by G2's Change Coupling Index.

\emph{What you change:} Simulate a ``discount'' feature that spans two modules. In Orders, add discount application logic; in Payments, add discounted-amount calculation:

\begin{lstlisting}[language=TypeScript,caption={Orders: apply discount (commit 1/3)},label={lst:g2-ex2-orders}]
// libs/modules/orders/src/features/apply-discount/handler.ts
export class ApplyDiscountHandler {
  execute(orderId: string, pct: number) {
    // apply percentage discount to order total
  }
}
\end{lstlisting}

\begin{lstlisting}[language=TypeScript,caption={Payments: calculate discounted amount (same commit)},label={lst:g2-ex2-payments}]
// libs/modules/payments/src/features/calc-discount/handler.ts
export class CalcDiscountedAmountHandler {
  execute(orderId: string, pct: number) {
    // recalculate payment amount after discount
  }
}
\end{lstlisting}

Repeat this pattern across three consecutive commits (add feature, fix edge case, update validation)---each commit touches files in \emph{both} modules.

\emph{What you run:}
\begin{lstlisting}[language=bash,caption={Compute co-change coupling from git history},label={lst:g2-ex2-run}]
npm run test:boundary   # G1 checks

# Detect co-changes between Orders and Payments (last 50 commits)
git log --pretty=format:"%h" -50 | while read sha; do
  files=$(git diff-tree --no-commit-id --name-only -r "$sha")
  has_orders=$(echo "$files" | grep -c "modules/orders" || true)
  has_payments=$(echo "$files" | grep -c "modules/payments" || true)
  if [ "$has_orders" -gt 0 ] && [ "$has_payments" -gt 0 ]; then
    echo "CO-CHANGE: $sha"
  fi
done
\end{lstlisting}

\emph{Expected signal:} G1 boundary checks: \textbf{pass} \checkmark{} --- no direct imports exist between Orders and Payments; $C_{\mathrm{leak}} = 0$, $C_{\mathrm{undecl}} = 0$, $C_{\mathrm{forbid}} = 0$. All G1 metrics remain at baseline. However, the CCI between Orders and Payments rises sharply: 3 out of the last 5 Orders commits also touch Payments, yielding $\mathrm{CCI}_{\mathrm{Orders \leftrightarrow Payments}} = 0.6$. This signals that a business feature lacks clear ownership---changes cannot be made to one module without coordinating with the other.

\emph{Fix:} Extract the discount logic into a dedicated feature module (\texttt{modules-pricing}) or consolidate it into whichever module owns the pricing domain concept. The goal is to reduce CCI by giving the cross-cutting concern a single home, so that future discount changes touch only one module.

\emph{G2 insight:} Structural independence (G1) does not guarantee \emph{change} independence---CCI reveals temporal coupling that only manifests in the commit history, making it a purely longitudinal G2 signal.

\subsubsection*{Exercise 3: Gradual Public Surface Bloat ($G_{\mathrm{api}}\uparrow$)}
Demonstrate how a module's public surface can inflate with \emph{legitimate} exports---valid handlers, not internal entities---while every G1 check remains green. The danger is not what is exported, but \emph{how much}: each new public symbol is a downstream obligation that freezes internal design choices.

\emph{What you change:} In \texttt{libs/modules/orders/src/index.ts}, add five new query handlers that are perfectly valid public capabilities:

\begin{lstlisting}[language=TypeScript,caption={Surface bloat: valid but excessive exports},label={lst:g2-ex3-violation}]
// libs/modules/orders/src/index.ts
// --- existing exports (9 symbols) ---
export { PlaceOrderHandler } from './features/place-order/handler';
export { GetOrderHandler } from './features/get-order/handler';
// ... (7 more existing handlers/listeners)

// --- NEW: 5 additional query handlers in one sprint ---
export { GetOrdersByStatusHandler }
  from './features/get-orders-by-status/handler';
export { GetOrdersByDateHandler }
  from './features/get-orders-by-date/handler';
export { GetOrdersByCustomerAndStatusHandler }
  from './features/get-orders-by-customer-status/handler';
export { CountOrdersHandler }
  from './features/count-orders/handler';
export { ExportOrdersHandler }
  from './features/export-orders/handler';
\end{lstlisting}

\emph{What you run:}
\begin{lstlisting}[language=bash,caption={Run enforcement after Exercise 3},label={lst:g2-ex3-run}]
npm run test:boundary           # G1 checks
npm run metrics:maintainability  # G2 metrics

# Quick manual check: count public symbols
node -e "const m = require('@tiny-store/modules-orders');
  console.log('G_api =', Object.keys(m).length);"
\end{lstlisting}

\emph{Expected signal:} G1 boundary checks: \textbf{pass} \checkmark{} --- every exported symbol is a handler (not an internal entity), so $C_{\mathrm{leak}} = 0$, $C_{\mathrm{undecl}} = 0$, $C_{\mathrm{forbid}} = 0$. G1 is fully green. However, $G_{\mathrm{api}}$ for Orders jumps from 9 to 14 in a single sprint---a 56\% increase. Each new export is a contract that downstream consumers may depend on, progressively freezing the module's internal structure and making future refactoring more expensive.

\emph{Fix:} Apply the \emph{minimal public surface} principle: expose only the handlers that external modules actually consume today. The five query handlers are likely consumed only by the HTTP adapter within Orders itself; they should remain internal and be wired through the module's own composition, not exported through \texttt{index.ts}. Set a $G_{\mathrm{api}}$ threshold (e.g., $\leq 12$ per module) in CI to catch surface inflation early.

\emph{G2 insight:} G1 guards \emph{what kind} of symbol crosses the boundary; G2 guards \emph{how many}---surface bloat is invisible to boundary correctness checks but directly degrades long-term maintainability by expanding the module's contractual obligations.

\pagebreak
\subsubsection*{Exercise Summary}
\small
\noindent
\begin{tabularx}{\linewidth}{p{0.04\linewidth} X p{0.22\linewidth} p{0.18\linewidth} p{0.10\linewidth}}
\textbf{Ex.} & \textbf{What you change} & \textbf{Run} & \textbf{G2 signal} & \textbf{G1 status} \\
0 & Establish baseline & \texttt{test:boundary}\newline\texttt{metrics:maint.} & all pass & \checkmark{} pass \\
1 & Re-export handlers via shared barrel & \texttt{test:boundary}\newline\texttt{metrics:maint.} & $\rho_{\mathrm{api}}\downarrow$ & \checkmark{} pass \\
2 & Co-change Orders + Payments for discount feature & \texttt{test:boundary}\newline\texttt{git log} analysis & $\mathrm{CCI}\uparrow$ & \checkmark{} pass \\
3 & Add 5 valid query handlers to Orders \texttt{index.ts} & \texttt{test:boundary}\newline\texttt{metrics:maint.} & $G_{\mathrm{api}}\uparrow$ (9$\to$14) & \checkmark{} pass \\
\end{tabularx}
\normalsize

\subsection*{Conclusion of the G2 Implementation}
This section demonstrated that embedding maintainability in a modular monolith is not a matter of code quality alone---it requires structural discipline that is measurable and enforceable. In Tiny Store, G2 is realized through layered internal organization that insulates domain logic, unidirectional dependency flow that prevents cascading change, controlled API surfaces that limit downstream obligations, and centralized composition that keeps cross-module wiring auditable.

The exercise walkthrough showed that each common maintainability anti-pattern---cross-module internal reuse, bidirectional coupling, and API surface inflation---produces a specific, observable metric signal. This confirms that G2's metrics are not abstract: they detect real architectural drift in real code. When combined with G1's boundary enforcement, these signals create a layered defense where boundary violations are caught immediately and maintainability degradation is caught early, before it becomes structurally expensive to reverse.

Together, G1 and G2 establish the foundation for progressive scalability: boundaries that are both correct and sustainable. With coupling bounded and change locality preserved, the system retains the option to evolve incrementally---adding modules, extracting services, or scaling selectively---without the coordination overhead that characterizes tightly coupled monoliths.