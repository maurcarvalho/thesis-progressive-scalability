\pagebreak
\section{G2: Embed Maintainability}
\label{sec:g2-embed-maintainability}

This section presents G2, which focuses on embedding maintainability as an architectural property of modular monolith applications. In this dissertation, maintainability is framed economically as a bounded cost of change: the architecture constrains the expected effort, risk, and coordination required to modify the system as it evolves. Rather than treating maintainability as an indirect outcome of refactoring or developer discipline, G2 operationalizes it through explicit design constraints, stable interaction contracts, and continuous detection of architectural drift.

G2 builds directly on G1. While G1 enforces the existence of explicit modular boundaries, G2 ensures that those boundaries remain effective over time. Together, these guidelines prevent the gradual erosion that often causes traditional monoliths to regress into tightly coupled systems with monolithic change dynamics.

\subsection*{Intent and Rationale}
Empirical studies consistently show that the primary driver of maintainability degradation in monolithic systems is not system size, but the accumulation of hidden coupling, ambiguous dependency direction, and architectural drift over time \cite{gravanis2021dont,blinowski2022monolithic}. As systems evolve, convenience-driven shortcuts such as deep imports, shared utilities, and implicit wiring gradually increase the blast radius of change and raise coordination costs.

This dissertation treats maintainability as a preventive architectural concern. G2 preserves bounded cost of change by constraining how modules interact, how dependencies are introduced, and how responsibilities are distributed. The guideline prioritizes change locality, stable contracts, and controlled dependency growth over short-term reuse. These properties ensure that most changes remain confined to a single bounded context and that the effort required to evolve the system scales sublinearly with its size.

G2 extends G1 from boundary correctness to boundary sustainability. While G1 makes dependencies explicit and verifiable, G2 ensures that those dependencies remain limited in scope, stable under evolution, measurable through specific metrics, and economically manageable as the system grows \cite{arya2024beyond,berry2024isItWorth}.

\pagebreak
\subsection*{Conceptual Overview}
Maintainability is embedded by designing modules so that change remains local and predictable:
\begin{itemize}[itemsep=8pt,topsep=2pt]
  \item Each bounded context exposes a narrow and intentional public surface that represents stable capabilities rather than internal structure.
  \item Cross-module interaction occurs exclusively through explicit contracts, whether synchronous (public handler calls) or asynchronous (domain events and listener registrations).
  \item Dependency direction reflects responsibility and information flow, reducing the risk of cycles and cascading change.
  \item Architectural drift is detected early through automated longitudinal tracking of structural signals, making boundary sustainability measurable over time.
\end{itemize}

\subsection*{Applicability Conditions and Scope}
G2 applies to systems organized as modular monoliths, where multiple bounded context modules coexist within a single codebase and are expected to evolve continuously. The guideline assumes that:
\begin{itemize}[itemsep=8pt,topsep=2pt]
  \item Module boundaries are explicitly defined and at least partially enforced, as established by G1.
  \item Each module has clear ownership and a well-defined responsibility.
  \item Architectural drift is a realistic risk during ongoing feature development.
\end{itemize}

G2 does not prescribe specific frameworks, build tools, or CI pipelines. Its scope is limited to metrics definition, design-time and code-level practices that directly influence long-term changeability.

\subsection*{Objectives}
\begin{itemize}[itemsep=8pt,topsep=2pt]
  \item \emph{Bounded Cost of Change:} Limit change propagation across modules so that most modifications remain confined to a single bounded context.
  \item \emph{Stable Dependency Direction:} Stabilize dependency direction through disciplined layering and contract-first boundaries, preventing cycles and cascading change.
  \item \emph{Controlled API Surface:} Constrain the growth of module public surfaces to preserve internal refactoring freedom and minimize downstream contractual obligations.
  \item \emph{Change Impact Predictability:} Ensure that the blast radius of any modification is assessable before implementation, through explicit dependency graphs and stable interaction contracts.
  \item \emph{Automated Drift Detection:} Detect architectural drift automatically through longitudinal metric tracking before it becomes structurally expensive to reverse.
  \item \emph{Independent Module Testability:} Ensure that each module remains independently testable using only its declared dependencies, validating that isolation holds at runtime as well as at the static level.
  \item \emph{Incremental Evolution:} Preserve the option for incremental refactoring and future decomposition without requiring system-wide coordination.
\end{itemize}

\pagebreak
\subsection*{Key Principles}
\begin{itemize}[itemsep=8pt,topsep=2pt]
  \item \emph{Encapsulation before reuse:} Cross-module reuse of internal code is treated as a maintainability risk unless mediated through an explicit contract.
  \item \emph{Contract over structure:} Modules depend on declared interfaces or events, not on internal implementation details.
  \item \emph{Unidirectional dependency flow:} Dependency direction reflects responsibility and information flow, and cycles are considered maintainability violations.
  \item \emph{Change locality:} Most changes should be implementable within a single module.
  \item \emph{Evolution over speculation:} Abstractions are introduced to support observed change, not anticipated reuse.
\end{itemize}

\subsection*{Implementation Mechanisms}
G2 is implemented through established software engineering practices rather than framework-specific mechanisms:
\begin{itemize}[itemsep=8pt,topsep=2pt]
  \item \emph{Layered internal structure:} Within each bounded context, code is organized into domain, application, and infrastructure concerns, ensuring that business rules remain insulated from volatile technical details.
  \item \emph{Explicit module entrypoints:} Each module exposes a single public surface that defines its externally visible capabilities.
  \item \emph{Contract-oriented collaboration:} Cross-module interaction occurs through synchronous interfaces or published domain events.
  \item \emph{Centralized composition:} Wiring between modules is visible and auditable, preventing implicit coupling.
  \item \emph{Governed exceptions:} Deviations from dependency or layering rules require explicit justification.
\end{itemize}

\subsection*{Common Failure Modes and Anti-Patterns}
The following failure modes are frequently observed in modular monoliths that lack explicit maintainability discipline. Each anti-pattern increases the cost of change by expanding the blast radius of modifications, weakening ownership boundaries, or introducing hidden coupling. For each anti-pattern, G2 defines one or more metrics that make the degradation observable and verifiable.

\begin{itemize}[itemsep=8pt,topsep=2pt]
  \item \emph{Cross-Module Internal Reuse:} Reusing internal classes or utilities from another module instead of interacting through a declared public API tightly couples the consumer to the provider's internal structure~\cite{parnas1972informationhiding}. Internal refactoring then forces coordinated changes across modules, undermining independent evolution. This anti-pattern is primarily detected through an increase in encapsulation leakage count ($C_{\mathrm{leak}}$) and a reduction in the API-only dependency ratio ($\rho_{\mathrm{api}}$).

  \item \emph{Implicit Dependency Introduction:} Dependencies introduced through configuration, dependency injection wiring, or reflection without explicit declaration bypass architectural review~\cite{fairbanks2010justenough}. Over time, they erode the reliability of dependency models and increase the effort required to assess change impact. This failure mode is reflected by an increase in undeclared dependency references ($C_{\mathrm{undecl}}$) and by reduced module isolation test pass rates ($P_{\mathrm{iso}}$).

  \item \emph{Bidirectional or Cyclic Dependencies:} Allowing modules to depend on each other directly or indirectly introduces cycles that prevent independent evolution~\cite{martin2012clean,yourdon1979structured}. Cycles increase cognitive load and coordination cost and are expensive to remove once established. This anti-pattern is detected through forbidden dependency references ($C_{\mathrm{forbid}}$) and explicit cycle analysis of the module dependency graph.

  \item \emph{Overloaded Module APIs:} Uncontrolled growth of a module's public surface leads to unstable interfaces and defensive design~\cite{parnas1972informationhiding}. Refactoring becomes increasingly risky, and internal structure gradually freezes. This failure mode is indicated by a declining API-only dependency ratio ($\rho_{\mathrm{api}}$) and sustained growth of the module's public API surface over time.

  \item \emph{Feature-Centric Coupling Across Modules:} When features span multiple modules without clear ownership, features rather than modules become the primary unit of change. This pattern increases coordination cost and dilutes accountability~\cite{FordParsons2017}. It is weakly visible in static dependencies but becomes evident through repeated cross-module co-changes and elevated architectural drift incidents.
\end{itemize}

These anti-patterns emerge when local convenience is prioritized over long-term change cost. G2 addresses them by enforcing explicit contracts, constraining dependency growth, and making structural erosion observable before it becomes irreversible.

\subsubsection*{The Sustainability Gap}

\noindent
The anti-patterns described above share a common characteristic: they are invisible to boundary enforcement alone. A system can pass every G1 gate (zero undeclared references, zero forbidden dependencies, zero encapsulation leaks) and still accumulate maintainability debt through structurally valid but economically unsustainable patterns. Convenience-driven type coupling through public entrypoints, transitive orchestration chains in the composition root, and gradual API surface inflation all respect module boundaries while eroding the cost-of-change properties that those boundaries were designed to protect.

This gap between boundary correctness and boundary sustainability is the central challenge G2 addresses. Where G1's Enforcement Gap argues that architectural knowledge without automation is insufficient, G2's Sustainability Gap argues that point-in-time correctness without longitudinal tracking is insufficient. A single snapshot of the dependency graph reveals whether boundaries are intact; only a time series reveals whether they are drifting. The metrics introduced below operationalize this longitudinal perspective, transforming maintainability from an aspirational property into a measurable, trend-aware constraint.

\subsection*{Metrics and Verification}
Maintainability in G2 is assessed through a set of explicit, measurable structural signals that capture boundary erosion, hidden coupling, and architectural drift over time. These metrics operationalize maintainability as a bounded cost of change by making the growth of coupling, dependency instability, and encapsulation violations observable and verifiable.

G2 builds directly on the enforcement model introduced in G1. While G1 establishes the correctness of modular boundaries, G2 uses quantitative signals to assess whether those boundaries remain effective as the system evolves. The quality measurement baseline derived from G1 (Section~\ref{sec:g1-enforce-modular-boundaries}) is reused here as the foundation for maintainability verification.

\noindent
G2 inherits the full set of boundary enforcement metrics from G1 and extends them with maintainability-specific signals that capture architectural drift, API inflation, and temporal coupling. Together, these metrics operationalize maintainability as a bounded cost of change.

\medskip\noindent\emph{Notation.} Let $M$ be the set of bounded-context modules. Let $R$ be the multiset of observed cross-module references, including static imports, dependency injection wiring, and event handlers. Let $D \subseteq M \times M$ be the set of declared allowed dependencies (\emph{requires}) and $F \subseteq M \times M$ be the set of explicitly forbidden dependencies (\emph{forbids}).

\subsubsection*{Inherited Boundary Metrics}

G2 inherits the five boundary enforcement metrics defined in G1 (Section~\ref{sec:g1-enforce-modular-boundaries}): $C_{\mathrm{undecl}}$ (Undeclared Dependency Reference Count), $C_{\mathrm{forbid}}$ (Forbidden Dependency Reference Count), $C_{\mathrm{leak}}$ (Encapsulation Leakage Count), $P_{\mathrm{iso}}$ (Module Isolation Test Pass Rate), and $C_{\mathrm{event}}$ (Event Subscription Boundary Violations). Their definitions, equations, and thresholds remain identical. In G2, however, these metrics are tracked \emph{longitudinally} rather than evaluated at a single point in time: sustained increases in any inherited metric signal architectural drift that point-in-time enforcement alone cannot detect.

\subsubsection*{Maintainability-Specific Metrics}

The following four metrics are unique to G2. They capture maintainability risks that emerge over time and are not fully addressed by boundary correctness alone.

\begin{itemize}[itemsep=8pt,topsep=2pt]
  \item \textbf{API-Only Dependency Ratio ($\rho_{\mathrm{api}}$):}
  The stability of a modular system depends critically on whether cross-module dependencies target stable, intentional interfaces rather than internal implementation details~\cite{parnas1972informationhiding}. When modules depend directly on internal structures of other modules, refactoring becomes a system-wide coordination problem rather than a local concern. This metric measures the proportion of cross-module references that respect encapsulation boundaries by targeting only the provider module's explicitly declared public surface.
  Let $R_{\mathrm{api}} \subseteq R$ be references targeting only the provider module's public surface:
  \[
    \rho_{\mathrm{api}} = \frac{|R_{\mathrm{api}}|}{|R|}
  \]
  \emph{Target:} $\rho_{\mathrm{api}} \geq 95\%$ (nearly all dependencies through public APIs). \\
  \emph{Verification intent:} constrain change propagation and stabilize interaction surfaces.\\

  \item \textbf{Boundary Bypass Surface Count ($C_{\mathrm{bypass}}$, optional):}
  Some programming environments provide mechanisms that can circumvent static boundary enforcement, such as reflection, dynamic loading, or configuration-driven wiring~\cite{martin2012clean}. While these mechanisms may serve legitimate purposes, their excessive use creates interaction paths that are invisible to static analysis and difficult to reason about during maintenance. This metric identifies locations where such bypass mechanisms are employed, highlighting potential architectural risk points that require careful documentation and monitoring.
  Let $S_{\mathrm{bypass}}$ be occurrences of bypass mechanisms within cross-module interaction paths:
  \[
    C_{\mathrm{bypass}} = |S_{\mathrm{bypass}}|
  \]
  \emph{Target:} $C_{\mathrm{bypass}} \to 0$ (minimize boundary bypass mechanisms). \\
  \emph{Verification intent:} identify high-risk interaction paths that undermine architectural guarantees.\\

  \item \textbf{Public API Surface Growth Rate ($G_{\mathrm{api}}$):}
  The size of a module's public API surface directly impacts maintainability by creating downstream contractual obligations~\cite{parnas1972informationhiding}. Each exported interface, handler, or event represents a commitment to external consumers that constrains internal refactoring freedom. Sustained growth in API surface area indicates that the module may be accumulating too many responsibilities or exposing internal concerns that should remain encapsulated. This longitudinal metric helps identify modules that are becoming increasingly difficult to evolve independently.
  \[
    G_{\mathrm{api}}(m) = \frac{|API_m(t)| - |API_m(t - \Delta t)|}{\Delta t}
  \]
  \emph{Target:} $G_{\mathrm{api}}(m) \to 0$ over time (stable API surface growth). \\
  \emph{Action:} consolidate contracts, remove accidental exposure, or split responsibilities.\\

  \item \textbf{Change Coupling Index ($CCI$, optional):}
  Modules that frequently change together across commits may indicate that they are more tightly coupled than their static dependency structure suggests~\cite{FordParsons2017}. This temporal coupling pattern often emerges when features span multiple modules without clear ownership, forcing coordinated changes that increase development friction and coordination costs. High change coupling suggests that the current modular boundaries may not align well with the natural evolution patterns of the system's features, potentially indicating a need for boundary redesign.
  Let $C(A,B)$ denote the number of commits where modules $A$ and $B$ change together within a defined time window:
  \[
    CCI = \frac{\sum_{A \neq B} C(A,B)}{\sum_{A} C(A)}
  \]
  \emph{Target:} $CCI \to 0.2$ (minimize co-change frequency to preserve independent evolution). \\
  \emph{Action:} reassign responsibilities, introduce clearer module contracts, or refactor feature orchestration logic.
\end{itemize}

\subsubsection*{Structural Health Metrics}

\noindent
The following metrics capture structural risks that are invisible to boundary enforcement and supplementary dependency analysis. They address uneven module growth, contract churn, and excessive fan-in: three failure modes that accumulate silently while all G1 and G2 structural checks remain green.

\begin{itemize}[itemsep=8pt,topsep=2pt]
  \item \textbf{Module Complexity Concentration} ($\Gamma$). \\
  As modular monoliths evolve, complexity tends to concentrate in a small number of modules that attract disproportionate feature development, becoming ``gravity wells'' that accumulate responsibilities beyond their original bounded context~\cite{martin2012clean}. When one module grows significantly larger than its peers in exported surface, internal size, or fan-in, it becomes the bottleneck for every cross-cutting change, even if its boundaries remain technically clean. This metric captures the ratio between the largest module's surface and the average, making uneven growth visible before it freezes the architecture.
  \[
    \Gamma = \frac{\max_{m \in M} |API_m|}{\frac{1}{|M|} \sum_{m \in M} |API_m|}
  \]
  \emph{Target:} $\Gamma \leq 3.0$. Values above 3.0 indicate that a single module dominates the system's public surface, warranting responsibility redistribution or module splitting.

  \item \textbf{Contract Stability Index} ($\sigma_m$). \\
  A module's public surface may remain constant in size while its contents churn: handlers are renamed, event schemas restructured, or DTOs reorganized across releases. This churn is invisible to the API surface growth rate ($G_{\mathrm{api}}$) but imposes significant coordination costs on downstream consumers, who must adapt to shifting contracts even when no new capability is added~\cite{parnas1972informationhiding}. The contract stability index captures this dimension by measuring the proportion of a module's public API that remains unchanged between measurement periods.
  \[
    \sigma_m = \frac{|\operatorname{API}_m(t) \cap \operatorname{API}_m(t - \Delta t)|}{|\operatorname{API}_m(t - \Delta t)|}
  \]
  \emph{Target:} $\sigma_m \geq 0.9$ per release cycle. A value below 0.9 indicates that more than 10\% of the module's public contract was modified, renamed, or removed, signaling instability that undermines downstream predictability.

  \item \textbf{Fan-In Concentration} ($\phi_m$). \\
  When a bounded context module is depended upon by a large proportion of other modules, it becomes a de facto shared library whose changes carry system-wide impact~\cite{yourdon1979structured}. High fan-in is expected for shared infrastructure (e.g., \texttt{shared-domain}, \texttt{shared-infrastructure}) but signals a design problem for domain modules: it means the module's responsibilities have expanded beyond its bounded context, or that other modules are coupling to its specifics rather than to stable abstractions. This metric measures the fraction of other modules that hold at least one dependency on module $m$.
  \[
    \phi_m = \frac{|\{A \in M \setminus \{m\} : \exists\, r \in \operatorname{refs}(A \to m)\}|}{|M| - 1}
  \]
  \emph{Target:} $\phi_m \leq 0.5$ for bounded context modules. No domain module should be depended upon by more than half the other modules in the system.
\end{itemize}

\noindent
\emph{Verification strategy and maintainability interpretation.} In G2, these metrics are treated as longitudinal signals of architectural health rather than isolated quality indicators. Increases in $C_{\mathrm{undecl}}$, $C_{\mathrm{leak}}$, or $C_{\mathrm{forbid}}$ indicate growing hidden coupling and rising cost of change. A declining $\rho_{\mathrm{api}}$ signals unstable dependency surfaces, while reductions in $P_{\mathrm{iso}}$ reveal erosion of modular isolation. By tracking these metrics over time and enforcing thresholds where appropriate, G2 enables early detection of architectural drift and supports timely refactoring while corrective actions remain localized and economically viable. The primary objective is not to eliminate change, but to ensure that its cost remains bounded as the system evolves.

\medskip
\noindent
\textbf{Compliance summary.} G2 maintainability compliance holds when:
\[
  C_{\mathrm{undecl}} = 0 \land C_{\mathrm{forbid}} = 0 \land C_{\mathrm{leak}} = 0 \land C_{\mathrm{event}} = 0 \land \rho_{\mathrm{api}} \geq 0.95 \land P_{\mathrm{iso}} = 1.0 \land \Gamma \leq 3.0 \land \sigma_m \geq 0.9 \land \phi_m \leq 0.5
\]

\subsection*{Documentation Guidelines}
\begin{itemize}[itemsep=8pt,topsep=2pt]
  \item \emph{Dependency Direction Map:}
  Maintain a visual or textual map of the allowed dependency direction between modules. This map complements G1's module descriptor by making the intended information flow explicit and reviewable during architectural discussions.

  \item \emph{Contract Change Log:}
  Whenever a module's public surface changes (new handler, modified event schema, deprecated endpoint), record the change with version metadata. This log supports backward-compatibility analysis and informs downstream consumers of evolving contracts.

  \item \emph{Architectural Drift Incidents:}
  When a metric threshold is crossed (e.g., $C_{\mathrm{undecl}} > 0$ or $\rho_{\mathrm{api}}$ drops below target), record the incident, root cause, and resolution. This creates a traceable history of maintainability interventions.
\end{itemize}

\subsection*{Tooling Capabilities Checklist}
Any open-source or proprietary tool used to support maintainability should address:
\begin{itemize}[itemsep=8pt,topsep=2pt]
  \item \emph{Dependency Graph Visualization:} Generate and display the module dependency graph, highlighting cycles, undeclared dependencies, and forbidden references.
  \item \emph{API Surface Analysis:} Track the size and growth rate of each module's public surface over time ($G_{\mathrm{api}}$).
  \item \emph{Change Coupling Detection:} Identify modules that frequently change together across commits ($CCI$), signaling feature-centric coupling or blurred ownership.
  \item \emph{Longitudinal Metric Tracking:} Store and visualize G2 metrics over time, enabling trend analysis and early detection of architectural drift.
  \item \emph{Contract Compatibility Checking:} Verify that changes to a module's public surface do not break downstream consumers, ideally integrated into the CI pipeline.
\end{itemize}

\subsection*{Reference Implementation}
G2's maintainability principles are demonstrated through the same Tiny Store reference implementation used in G1. The relevant structural artifacts are:
\begin{itemize}[itemsep=8pt,topsep=2pt]
  \item \texttt{libs/modules/*/src/index.ts}: Module entrypoints that define the public surface for each bounded context
  \item \texttt{libs/shared/testing/src/module-boundary.spec.ts}: Boundary verification tests that enforce dependency direction and detect encapsulation leakage
  \item \texttt{apps/api/src/app/lib/register-listeners.ts}: Centralized event wiring that makes cross-module collaboration auditable
  \item \texttt{nx.json}: Nx workspace configuration for monorepo management and module-aware CI
\end{itemize}

\subsection*{Literature Support Commentary}
Although maintainability is a central topic in software engineering, much of the literature treats it either as an abstract principle or as a collection of localized code quality metrics. Recent empirical studies and systematic reviews emphasize that maintainability improvements in modular monoliths are primarily driven by boundary discipline and dependency management rather than deployment decomposition alone~\cite{gravanis2021dont,berry2024isItWorth,blinowski2022monolithic}.

The relationship between modularity and maintainability has deep roots in information hiding~\cite{parnas1972informationhiding}. Recent systematic analyses confirm that modular monolith architectures can achieve maintainability levels comparable to microservices when boundary discipline is sustained over time~\cite{wolfart2021modernizing,blinowski2022monolithic}. The critical differentiator is not the deployment topology but the rigor with which dependency direction and encapsulation are enforced as the codebase evolves~\cite{abgaz2023decomposition}.

Change coupling as an architectural health signal has been explored in the context of microservices migration, where co-change analysis reveals hidden dependencies that static structure cannot capture~\cite{fritzsch2019,deLauretis2019from}. G2 adapts this insight to the modular monolith context, where the absence of deployment boundaries makes temporal coupling even more difficult to detect without deliberate instrumentation.

Evolutionary architecture research further argues that architectural properties such as maintainability must be preserved through objective, executable constraints rather than informal guidance~\cite{FordParsons2017}. The concept of \emph{architectural fitness functions}~\cite{thoughtworks2017fitnessfunction} operationalizes this perspective by defining automated checks that continuously verify whether the architecture satisfies its intended properties. G2 synthesizes these insights by framing maintainability as bounded cost of change and by providing concrete design mechanisms and measurable signals grounded in the boundary enforcement model established by G1.

%% ============================================================
%% G2 APPLIED
%% ============================================================
\pagebreak
\subsection*{G2 Applied: Maintainability in the Tiny Store}
\label{sec:g2-applied}

G1 answers a binary question: \emph{are boundaries enforced right now?} A single failing boundary test is enough to detect and fix a violation. G2 asks a fundamentally different question: \emph{are boundaries sustainable over time?} The answer is not binary but longitudinal; it emerges from tracking how dependency structure, API surface size, and change coupling evolve across commits, sprints, and releases. A system can pass every G1 check and still degrade in maintainability if convenience-driven shortcuts accumulate, public surfaces inflate, or dependency direction drifts silently.

This section operationalizes G2 using the Tiny Store reference implementation. Where G1's tutorial focused on the Orders--Inventory boundary, G2 shifts attention to the Payments and Shipments contexts, smaller modules whose evolution patterns reveal maintainability risks that are invisible to boundary checks alone. The tutorial introduces dependency graph analysis, API surface measurement, and change coupling detection as G2-specific tooling. The exercises demonstrate failure modes that \emph{pass all G1 gates} yet degrade the longitudinal health metrics defined in G2.

\subsection*{Reader Map}
This tutorial assumes the G1 baseline is passing and takes approximately 30 minutes. You will first learn to extract a dependency direction map and compute API surface metrics from the live codebase. Then you will run three exercises, each introducing a maintainability anti-pattern that is technically valid under G1 but produces a measurable signal under G2. The exercises use the Payments and Shipments modules exclusively, so there is no overlap with G1's Orders--Inventory walkthrough.

\pagebreak
\subsection*{Tutorial: Step-by-Step Application}

\subsubsection*{Step 1: Extract the Dependency Direction Map}
G2 requires that dependency direction reflects responsibility and information flow. The first maintainability-specific action is to extract and visualize the actual dependency graph, then compare it against the intended architecture.

\begin{lstlisting}[language=bash,caption={Extract the module dependency graph},label={lst:g2-dep-graph}]
# Generate the Nx dependency graph (opens in browser)
npx nx graph

# For CI or scripted analysis, export as JSON:
npx nx graph --file=dep-graph.json
cat dep-graph.json | python3 -c "
import json, sys
g = json.load(sys.stdin)['graph']
for src, data in g['dependencies'].items():
    if 'modules-' in src:
        for dep in data:
            tgt = dep['target']
            if 'modules-' in tgt or 'shared-' in tgt:
                print(f'  {src} -> {tgt}')
"
\end{lstlisting}

In a healthy Tiny Store baseline, the output shows that every bounded-context module depends only on shared libraries. No module-to-module edge exists at the library level:

\begin{lstlisting}[language=bash,caption={Expected dependency direction (baseline)},label={lst:g2-dep-baseline}]
  modules-orders    -> shared-domain
  modules-orders    -> shared-infrastructure
  modules-inventory -> shared-domain
  modules-inventory -> shared-infrastructure
  modules-payments  -> shared-domain
  modules-payments  -> shared-infrastructure
  modules-shipments -> shared-domain
  modules-shipments -> shared-infrastructure
\end{lstlisting}

Cross-module coupling exists only in the composition root (\texttt{register-listeners.ts}), which lives in \texttt{apps/api}, not inside any module. This is a G2 invariant: if a module-to-module edge appears in the dependency graph, it signals that coupling has migrated from the auditable composition root into module internals, violating unidirectional dependency flow.

\subsubsection*{Step 2: Measure the API Surface per Module}
G2 tracks the public API surface size ($|API_m|$) and its growth rate ($G_{\mathrm{api}}$) as longitudinal health signals. A growing surface creates downstream obligations and reduces refactoring freedom. Measure the current baseline:

\begin{lstlisting}[language=bash,caption={Count exported symbols per module},label={lst:g2-api-surface}]
for mod in orders inventory payments shipments; do
  count=$(grep -c "^export" \
    libs/modules/$mod/src/index.ts 2>/dev/null || echo 0)
  echo "$mod: $count exports"
done
\end{lstlisting}

Expected baseline output:

\begin{lstlisting}[language=bash,caption={API surface baseline},label={lst:g2-api-baseline}]
orders:    20 exports  (4 handlers + 4 DTOs + 7 events + 5 listeners)
inventory: 16 exports  (5 handlers + 5 DTOs + 3 events + 3 listeners)
payments:   7 exports  (2 handlers + 2 DTOs + 2 events + 1 listener)
shipments:  8 exports  (2 handlers + 2 DTOs + 3 events + 1 listener)
\end{lstlisting}

These numbers form the $t_0$ snapshot for $G_{\mathrm{api}}$. In a CI pipeline, this count would be recorded per commit so that sustained growth triggers a review. Notice that Payments and Shipments have the smallest surfaces (7 and 8 exports respectively); they are lean contracts. G2's objective is to keep them that way as the system evolves.

\subsubsection*{Step 3: Audit Cross-Module Wiring Density}
G1 established that \texttt{register-listeners.ts} centralizes event subscriptions. G2 goes further by treating this file as a \emph{coupling density indicator}: the number of cross-module subscription lines reflects the coordination cost of the system. Count them:

\begin{lstlisting}[language=bash,caption={Count cross-module subscriptions},label={lst:g2-wiring-density}]
grep -c "eventBus.subscribe" \
  apps/api/src/app/lib/register-listeners.ts
# Baseline: 23 subscriptions (13 event-store + 10 listener wiring)
\end{lstlisting}

This number is not inherently good or bad; it reflects the system's current collaboration complexity. The G2 concern is \emph{growth rate}: if this count doubles after adding one feature, the wiring is likely feature-centric rather than bounded-context-oriented, signaling the ``Feature-Centric Coupling'' anti-pattern described in the failure modes section.

\subsubsection*{Step 4: Compute $\rho_{\mathrm{api}}$ from the Composition Root}
The API-only dependency ratio ($\rho_{\mathrm{api}}$) measures whether cross-module references target public entrypoints or internal paths. In Tiny Store, all imports in \texttt{register-listeners.ts} use the public path \texttt{@tiny-store/modules-*}:

\begin{lstlisting}[language=TypeScript,caption={All composition root imports use public entrypoints},label={lst:g2-rho-api}]
import { OrderPlacedListener } from '@tiny-store/modules-inventory';
import { InventoryReservedListener } from '@tiny-store/modules-orders';
import { PaymentProcessedListener } from '@tiny-store/modules-orders';
import { OrderConfirmedListener } from '@tiny-store/modules-payments';
import { OrderPaidListener } from '@tiny-store/modules-shipments';
// ... 8 more listener/handler imports from other modules
\end{lstlisting}

None of these imports target internal paths (e.g., \texttt{@tiny-store/modules-payments/src/domain/...}). With all cross-module references routing through public surfaces, $\rho_{\mathrm{api}} = 1.0$. Any deviation from 1.0 means an internal path has leaked into the composition root, a maintainability regression that G1's boundary tests may not catch if the import resolves correctly at runtime.

\subsubsection*{Step 5: Detect Change Coupling via Co-Change Analysis}
G2 defines the Change Coupling Index ($CCI$) as a supplementary metric that captures modules changing together across commits. This is not detectable by static analysis; it requires commit history:

\begin{lstlisting}[language=bash,caption={Detect co-changing modules in recent commits},label={lst:g2-cci}]
# List modules touched per commit, flag co-changes
git log --oneline -50 --name-only | \
  awk '/^[a-f0-9]/{commit=$1; next}
       /^libs\/modules\//{split($0,a,"/"); mods[commit][a[3]]}
       END{for(c in mods) if(length(mods[c])>1)
         print c, ":", length(mods[c]), "modules"}'
\end{lstlisting}

In the Tiny Store baseline, the only multi-module commits are infrastructure changes (boundary refactoring, test additions) that intentionally touched all four modules simultaneously. No feature commit crosses module boundaries:

\begin{lstlisting}[language=bash,caption={Co-change analysis output (baseline)},label={lst:g2-cci-output}]
# Infrastructure commits (expected multi-module):
62354e5  2 modules: payments, shipments    # test suites added
2802a45  4 modules: inventory, orders,     # boundary refactoring
         payments, shipments
# Feature commits: none cross module boundaries
# CCI = 0.0 for feature work (healthy baseline)
\end{lstlisting}

In a healthy codebase, most feature commits touch a single module. When Payments and Shipments consistently change together (e.g., every shipment feature also modifies payment logic), it indicates that responsibility boundaries are blurred, even if no import violations exist. This is precisely the kind of degradation G2 is designed to surface: structurally valid code with economically unsustainable change patterns.

\subsubsection*{Step 6: Understand the Longitudinal Perspective}
The key distinction between G1 and G2 enforcement is \emph{when} degradation becomes visible. G1 catches violations at the moment they are introduced (a failing test, a lint error). G2 catches degradation that accumulates over time: a public surface that grows by one export per sprint, a $\rho_{\mathrm{api}}$ that drops from 1.0 to 0.95 to 0.87 across releases, a $CCI$ that rises as features span more modules.

This means G2 metrics must be \emph{tracked}, not just \emph{checked}. The recommended practice is to record the following values at each release milestone:

\begin{itemize}[itemsep=8pt,topsep=2pt]
  \item $|API_m|$ per module (from Step 2)
  \item $\rho_{\mathrm{api}}$ (from Step 4)
  \item Wiring density in \texttt{register-listeners.ts} (from Step 3)
  \item $CCI$ over the most recent $N$ commits (from Step 5)
\end{itemize}

A single anomalous value is not alarming. A sustained trend (three consecutive sprints where Payments' surface grows, or $\rho_{\mathrm{api}}$ declines monotonically) triggers an architectural review. This longitudinal framing is what separates G2 from G1: boundaries are not just correct, but \emph{economically sustainable}.

\pagebreak
\subsection*{Exercise Walkthrough: Controlled Maintainability Degradation}
The exercises below differ fundamentally from G1's exercises. G1 introduced violations that immediately fail a boundary check (binary signal). G2 introduces changes that \emph{pass all G1 gates} but degrade maintainability metrics over time (longitudinal signal). Each exercise uses the Payments or Shipments module to avoid overlap with G1's Orders--Inventory examples.

\subsubsection*{Exercise 0: Establish the G2 Maintainability Baseline}
Record the starting values for all G2 metrics. These form the $t_0$ reference against which degradation is measured.

\begin{lstlisting}[language=bash,caption={G2 maintainability baseline},label={lst:g2-ex0}]
# 1. Confirm G1 gates still pass
npm run test:boundary && npm run test:integration

# 2. Record API surface sizes
for mod in orders inventory payments shipments; do
  echo "$mod: $(grep -c '^export' \
    libs/modules/$mod/src/index.ts) exports"
done
# payments: 7, shipments: 8

# 3. Record rho_api
grep -c "@tiny-store/modules-" \
  apps/api/src/app/lib/register-listeners.ts
# All via public entrypoints -> rho_api = 1.0

# 4. Record dependency graph (no module-to-module edges)
npx nx graph --file=dep-graph.json
\end{lstlisting}

Baseline: $|API_{\mathrm{payments}}| = 7$, $|API_{\mathrm{shipments}}| = 8$, $\rho_{\mathrm{api}} = 1.0$, $C_{\mathrm{forbid}} = 0$, zero module-to-module edges.

\subsubsection*{Exercise 1: Convenience Shortcut That Passes G1 ($\rho_{\mathrm{api}}\downarrow$, $C_{\mathrm{undecl}}\uparrow$)}
A developer working on the Shipments module needs the \texttt{PaymentStatus} enum to decide whether to hold a shipment. Instead of enriching the event payload or introducing a query contract, they take a shortcut that \emph{technically passes G1's boundary tests} by re-exporting an internal enum that was deliberately excluded from the public surface during refactoring.

\emph{What you change:}

First, in \texttt{libs/modules/payments/src/index.ts}, re-export an internal enum that was deliberately excluded from the public surface:
\begin{lstlisting}[language=TypeScript,caption={Step 1: Payments exports an internal enum},label={lst:g2-ex1-step1}]
// "Temporary" export added for cross-module convenience
export * from './domain/enums/payment-status.enum';
\end{lstlisting}

Then, in \texttt{libs/modules/shipments/src/features/create-shipment/service.ts}, consume it:
\begin{lstlisting}[language=TypeScript,caption={Step 2: Shipments depends on Payments' internal type},label={lst:g2-ex1-step2}]
import { PaymentStatus } from '@tiny-store/modules-payments';

// Now create-shipment logic checks payment status directly
if (paymentStatus !== PaymentStatus.SUCCEEDED) {
  throw new Error('Cannot ship unpaid order');
}
\end{lstlisting}

\emph{What you run:}
\begin{lstlisting}[language=bash,caption={Verify G1 passes but G2 degrades},label={lst:g2-ex1-run}]
# G1 gate: PASSES (import uses public entrypoint)
npm run test:boundary
# All green -- G1 sees no violation

# G2 metrics: DEGRADED
# 1. API surface grew
grep -c "^export" libs/modules/payments/src/index.ts
# Was 7, now 8 -> G_api(payments) = +1

# 2. Dependency graph gained a module-to-module edge
npx nx graph --file=dep-graph.json
# New edge: modules-shipments -> modules-payments
# This edge did NOT exist at baseline

# 3. rho_api still 1.0 (import uses public path)
# BUT the dependency is structurally new and undeclared
# C_undecl rises from 0 to 1
\end{lstlisting}

\emph{Why this matters for G2:} The Nx dependency graph now shows \texttt{modules-shipments $\rightarrow$ modules-payments}, a direct module-to-module edge that did not exist at baseline. G1 does not flag this because the import resolves through a public entrypoint. But G2 detects it as architectural drift: Shipments can no longer evolve independently of Payments' domain model. A refactoring of \texttt{PaymentStatus} now forces a coordinated change across two bounded contexts. The cost of change has increased, even though no boundary test failed.

\emph{Fix:} Remove the enum export from Payments' \texttt{index.ts}. If Shipments needs payment-readiness information, enrich the \texttt{OrderPaid} event payload to include the relevant status, keeping the interaction contract-based rather than type-coupled.

\subsubsection*{Exercise 2: Transitive Orchestration in the Composition Root ($C_{\mathrm{forbid}}\uparrow$, blast radius)}
The composition root in \texttt{register-listeners.ts} already contains a pattern where the \texttt{OrderPaid} handler queries Orders for the shipping address before invoking Shipments' \texttt{CreateShipmentHandler}. A developer extends this pattern by also querying Payments to check whether the payment was refunded before creating the shipment. This creates a transitive coupling chain that spans three modules in a single event handler.

\emph{What you change:} In \texttt{register-listeners.ts}, modify the \texttt{OrderPaid} subscription to query Payments before creating a shipment:

\begin{lstlisting}[language=TypeScript,caption={Violation: three-module orchestration in one handler},label={lst:g2-ex2-violation}]
import { GetPaymentHandler } from '@tiny-store/modules-payments';

// In registerListeners():
const getPaymentHandler = new GetPaymentHandler(dataSource);

eventBus.subscribe('OrderPaid', async (event) => {
  const { orderId } = event.payload;
  // Query Payments to verify payment is not refunded
  const payment = await getPaymentHandler.handle(orderId);
  if (payment.status === 'REFUNDED') return;
  // Then query Orders for shipping address
  const order = await getOrderHandler.handle(orderId);
  await createShipmentHandler.handle({
    orderId,
    shippingAddress: order.shippingAddress,
  });
});
\end{lstlisting}

\emph{What you run:}
\begin{lstlisting}[language=bash,caption={Detect coupling density increase},label={lst:g2-ex2-run}]
# G1 gate: PASSES (composition root may import any public surface)
npm run test:boundary
# All green

# G2 analysis: coupling density and direction
# Count handler/listener instantiations in composition root:
grep -c "new.*Handler\|new.*Listener\|new.*Repository" \
  apps/api/src/app/lib/register-listeners.ts
# Was 12, now 13 -> wiring density increased

# Trace the transitive dependency chain:
# OrderPaid -> getPaymentHandler (Payments)
#           -> getOrderHandler (Orders)
#           -> createShipmentHandler (Shipments)
# Three modules are now coupled in a single event handler
\end{lstlisting}

\emph{Why this matters for G2:} No boundary test fails. But the \texttt{OrderPaid} handler now orchestrates three modules in sequence, creating a transitive dependency chain. If any of the three handlers changes its return type, the composition root breaks, and because the logic is interleaved in a single subscription, the blast radius spans Payments, Orders, and Shipments simultaneously. This violates G2's \emph{change locality} principle: a modification in Payments' response shape forces changes in code that nominally belongs to the Shipments workflow. The wiring density metric captures the growth, and a $C_{\mathrm{forbid}}$ increment is warranted if peer modules are declared as forbidden transitive dependencies.

\emph{Fix:} Enrich the \texttt{OrderPaid} event payload to include all data Shipments needs (shipping address, payment status). The composition root should wire events to handlers, not orchestrate multi-module queries. If orchestration is necessary, extract it into a dedicated saga or process manager with explicit ownership.

\subsubsection*{Exercise 3: Gradual Public Surface Bloat ($G_{\mathrm{api}}\uparrow$)}
Demonstrate how a module's public surface can inflate with \emph{legitimate} exports (valid handlers, not internal entities) while every G1 check remains green. The danger is not \emph{what kind} of symbol is exported, but \emph{how many}: each new public symbol is a downstream obligation that freezes internal design choices.

\emph{What you change:} In \texttt{libs/modules/payments/src/index.ts}, add five new handlers that are perfectly valid public capabilities:

\begin{lstlisting}[language=TypeScript,caption={Surface bloat: valid but excessive exports},label={lst:g2-ex3-violation}]
// libs/modules/payments/src/index.ts
// --- existing exports (7 symbols: 2 handlers + 2 DTOs + 2 events + 1 listener) ---
// ... existing handler, DTO, event, and listener exports ...

// --- NEW: 5 additional query handlers in one sprint ---
export * from './features/get-payments-by-order/handler';
export * from './features/get-payments-by-status/handler';
export * from './features/get-payments-by-date/handler';
export * from './features/refund-payment/handler';
export * from './features/retry-payment/handler';
\end{lstlisting}

\emph{What you run:}
\begin{lstlisting}[language=bash,caption={Measure surface inflation},label={lst:g2-ex3-run}]
# G1 gate: PASSES (all exports are handlers, not internals)
npm run test:boundary
# All green -- no encapsulation leak, no forbidden import

# G2 metric: API surface
grep -c "^export" libs/modules/payments/src/index.ts
# Was 7, now 12 -> G_api(payments) = +5 in one sprint
# |API_payments| grew from 7 to 12 (71% increase)
\end{lstlisting}

\emph{Why this matters for G2:} The Payments module went from a lean 7-symbol contract to a 12-symbol surface in a single sprint. Every exported handler is a contract that downstream consumers may depend on. Once another module or the composition root begins using \texttt{GetPaymentsByStatusHandler}, Payments can no longer rename, restructure, or remove that handler without coordinating a cross-module change. The module's internal refactoring freedom shrinks with each export. Over three sprints, if each adds 2 exports, $G_{\mathrm{api}}(\mathrm{payments}) \approx 2/\mathrm{sprint}$, a sustained growth rate that warrants consolidation.

G1 cannot detect this: every exported symbol is a handler (not an entity or repository), so $C_{\mathrm{leak}} = 0$. The issue is purely quantitative (\emph{how much} surface, not \emph{what kind}) and requires the longitudinal $G_{\mathrm{api}}$ metric to become visible.

\emph{Fix:} Remove exports that are consumed only within the module's own HTTP adapter or feature code. Expose only handlers that external modules actually invoke through the composition root. Set a $G_{\mathrm{api}}$ threshold (e.g., $\leq 10$ for lean modules like Payments) in CI to catch surface inflation early.

\pagebreak
\subsubsection*{Exercise Summary}
\small
\noindent
\begin{tabularx}{\linewidth}{p{0.04\linewidth} X p{0.22\linewidth} p{0.18\linewidth} p{0.10\linewidth}}
\textbf{Ex.} & \textbf{What you change} & \textbf{Run} & \textbf{G2 signal} & \textbf{G1 status} \\
0 & Record baseline metrics & API count, \texttt{nx graph}, CCI & $t_0$ snapshot & \checkmark{} pass \\
1 & Payments exports enum, Shipments consumes it & \texttt{nx graph}, API count & $C_{\mathrm{undecl}}\uparrow$, new edge & \checkmark{} pass \\
2 & Composition root orchestrates 3 modules & wiring density, chain trace & blast radius $\times 3$ & \checkmark{} pass \\
3 & Payments exports 5 valid handlers & API count & $G_{\mathrm{api}}\uparrow$ (7$\to$12) & \checkmark{} pass \\
\end{tabularx}
\normalsize

\vspace{0.5em}
\subsubsection*{New Metrics: Tiny Store Baseline}
The three additional maintainability metrics introduced in this guideline can be computed from the current Tiny Store state.

\emph{Module Complexity Concentration ($\Gamma$):} The API surfaces for each module are: Orders~=~20, Inventory~=~16, Payments~=~7, Shipments~=~8. The largest surface is 20 (Orders) and the mean across all four modules is 12.75. Applying the definition:

\begin{lstlisting}[language=bash,caption={$\Gamma$ computation},label={lst:g2-gamma-baseline}]
Gamma = max / mean = 20 / 12.75 = 1.57
\end{lstlisting}

\noindent
A value of 1.57 is well below the 3.0 threshold, confirming that no single module dominates the system's public surface.

\emph{Contract Stability Index ($\sigma_m$):} Comparing the current \texttt{index.ts} exports with the previous release, all modules retained their public symbols across the boundary refactoring; handlers, DTOs, events, and listeners remained unchanged.

\begin{lstlisting}[language=bash,caption={$\sigma_m$ baseline},label={lst:g2-sigma-baseline}]
sigma_m = 1.0 for all modules (zero contract churn)
\end{lstlisting}

\noindent
A value of 1.0 indicates full contract stability, the ideal starting point for longitudinal tracking.

\emph{Fan-In Concentration ($\phi_m$):} Fan-in measures how many other domain modules depend on a given module. In Tiny Store, all cross-module wiring flows through the composition root (\texttt{apps/api}), not between library modules directly:

\begin{lstlisting}[language=bash,caption={$\phi_m$ baseline},label={lst:g2-phi-baseline}]
orders:    depended on by 0 domain modules  (phi = 0.0)
inventory: depended on by 0 domain modules  (phi = 0.0)
payments:  depended on by 0 domain modules  (phi = 0.0)
shipments: depended on by 0 domain modules  (phi = 0.0)
\end{lstlisting}

\noindent
With $\phi_m = 0.0$ for all modules, no bounded context is a direct dependency of another, confirming healthy architectural isolation.

\vspace{0.5em}
\noindent
All three metrics are at healthy baseline levels: $\Gamma = 1.57$ (no module dominates), $\sigma_m = 1.0$ (zero contract churn), and $\phi_m = 0.0$ (no direct cross-module fan-in). These values establish the $t_0$ reference for longitudinal tracking alongside the other G2 metrics.

These structural health metrics complement the operational metrics from the previous sections ($\rho_{\mathrm{api}}$, $G_{\mathrm{api}}$, $CCI$) by capturing dimensions of maintainability that are invisible to dependency and API surface analysis alone. While $\rho_{\mathrm{api}}$ detects whether imports route through public entrypoints and $G_{\mathrm{api}}$ tracks surface inflation over time, $\Gamma$ reveals whether complexity is concentrating in a single module, $\sigma_m$ measures how stable contracts remain across releases, and $\phi_m$ quantifies how many modules would be affected if a given module's public surface changes. Together, the nine G2 metrics provide a comprehensive longitudinal view of maintainability: from boundary compliance (inherited from G1) through operational sustainability ($\rho_{\mathrm{api}}$, $G_{\mathrm{api}}$, $CCI$) to structural health ($\Gamma$, $\sigma_m$, $\phi_m$). Recording all nine at each release milestone ensures that degradation in any dimension becomes visible before it compounds into irreversible architectural debt.

\noindent\emph{Key observation:} All three exercises pass G1's \texttt{test:boundary} gate. The degradation is only visible through G2's longitudinal metrics: dependency graph edges, API surface counts, wiring density, and change coupling analysis. This confirms that boundary correctness (G1) and boundary sustainability (G2) are complementary but distinct architectural concerns.

\subsection*{Conclusion of the G2 Implementation}
This section demonstrated that maintainability in a modular monolith cannot be reduced to boundary enforcement alone. G1 ensures that boundaries are \emph{correct} at any given moment; G2 ensures that they remain \emph{economically sustainable} over time. The distinction is practical: a system can pass every boundary test while accumulating convenience-driven type coupling, inflated API surfaces, and feature-centric wiring that progressively raises the cost of change.

The tutorial introduced maintainability-specific tooling (dependency graph extraction, API surface counting, wiring density measurement, and co-change analysis) that operationalizes G2's metrics on a real codebase. The exercises showed that each failure mode produces a specific, measurable signal: a new module-to-module edge that did not exist at baseline ($C_{\mathrm{undecl}}$), a transitive orchestration chain that expands the blast radius of composition root changes, and a growing public surface that creates contractual obligations faster than the module can absorb them ($G_{\mathrm{api}}$). None of these violations were caught by G1's boundary tests; they required longitudinal tracking to become visible.

Together, G1 and G2 establish a layered defense for progressive scalability. G1 provides the immediate, binary gate that prevents structural violations. G2 provides the longitudinal, quantitative signals that detect gradual erosion before it becomes irreversible. With both guidelines in place, the architecture retains the option to evolve incrementally while keeping the cost of change bounded and predictable as the system grows. The next question is \emph{how} that incremental evolution should proceed: which scaling interventions are proportional to which bottlenecks, and in what order. This transition motivates Guideline G3, which formalizes progressive scalability as a structured, evidence-driven spectrum.
