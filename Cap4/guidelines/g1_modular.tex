\pagebreak
\section{G1: Enforce Modular Boundaries}
\label{sec:g1-enforce-modular-boundaries}

In this section, we present one of the concrete guidelines proposed for evolving a modular monolith application. G1 focuses on enforcing clear modular boundaries. The guideline aims to prevent unintended coupling in the codebase, preserve encapsulation, and ensure that dependencies between modules remain explicit and verifiable through build- and test-time checks.

\subsection*{Intent and Rationale}
This research proposes that modularity in a monolith should be treated as an enforceable architectural property rather than an assumed outcome of refactoring. Without enforcement, boundaries tend to degrade over time through convenience-driven imports, shared utilities, and implicit wiring, which gradually reintroduces tight coupling. G1 therefore treats boundary enforcement as a preventive control, making coupling explicit, reviewable, and auditable, enabling independent evolution of modules and reducing the cost of architectural change.

\subsection*{Conceptual Overview}
Define clear boundaries around each bounded-context module so that:
\begin{itemize}[itemsep=8pt,topsep=2pt]
  \item Each module encapsulates its internal implementation and feature-level organization.
  \item Dependencies between modules occur only through explicitly declared and verifiable interfaces, whether synchronous (public API calls) or asynchronous (event subscriptions and command channels).
  \item Unintended coupling is prevented through automated enforcement, enabling independent evolution of modules within a single deployable system.
\end{itemize}


\subsection*{Applicability Conditions and Scope}
G1 is applicable when a system is decomposed into logical modules within a single codebase. Inter-module dependencies must be explicitly declared and automatically verifiable, independent of packaging, deployment, or distribution decisions. This guideline assumes a two-level decomposition strategy:
\begin{itemize}[itemsep=8pt,topsep=2pt]
  \item \emph{Bounded Context Modules:} The codebase is decomposed into bounded-context modules (for example, under a \texttt{modules/} root), and each bounded context is treated as a first-class module boundary.
  \item \emph{Package-by-Feature Within Modules:} Inside each module, code is organized by feature (use cases, domain concepts, aggregates) to localize behavior and reduce scattering, without weakening the outer module boundary.
\end{itemize}
G1 focuses on enforcing the \emph{outer} boundary between bounded-context modules. The internal package-by-feature organization is treated as a complementary structuring mechanism, and its detailed rules are addressed in subsequent topics.

\subsection*{Objectives}
\begin{itemize}[itemsep=8pt,topsep=2pt]
  \item \emph{Clear Declaration and Isolation:} Ensure each module is clearly identified (for example, via naming conventions, package control, or a descriptor) and remains isolated unless an explicit dependency is declared.
  \item \emph{Encapsulation:} Keep internal classes, data, and resources hidden within a module.
  \item \emph{Controlled Dependency:} Allow one module to depend on another only when explicitly declared.
  \item \emph{Visibility Management:} Declare which services, events, or commands a module exposes or consumes.
  \item \emph{Automated Early Verification:} Detect boundary violations automatically at build or test time rather than at runtime, ensuring that enforcement is part of the CI pipeline rather than relying on manual review.
  \item \emph{Architectural Drift Prevention:} Defend module boundaries against the common erosion patterns (convenience imports, shared utility creep, implicit wiring) that accumulate during sustained development and reintroduce tight coupling.
  \item \emph{Isolation Guarantees:} Optionally forbid certain modules from ever depending on each other.
\end{itemize}

\subsection*{Key Principles}
\begin{itemize}[itemsep=8pt,topsep=2pt]
  \item \emph{Provided Interface vs.\ Internal Components:}
    \begin{itemize}[noitemsep,topsep=1pt,leftmargin=1.5em]
      \item \emph{Provided Interface:} Public classes, services, APIs, or events explicitly exposed to other modules.
      \item \emph{Internal Components:} Classes, utilities, or data that should remain private within the module.
    \end{itemize}

  \item \emph{Explicit Declarations:}
    All dependencies on other modules must be declared in a central descriptor to provide auto-verifiability (for example, annotation, configuration file, or YAML).

  \item \emph{Forbidden Dependencies:}
    Declare modules that must never depend on each other to enforce stronger isolation where necessary.

  \item \emph{Inter-Module Communication:}
    Use either synchronous calls via public interfaces or asynchronous event-driven channels, and avoid direct references to another module's internals.

  \item \emph{Boundary-First Discipline:}
    Package-by-feature improves cohesion within a bounded context, but it does not replace module boundaries. A feature slice must not become a cross-module dependency mechanism (for example, by importing internal feature code from other modules).
\end{itemize}

\subsection*{Implementation Mechanisms}
This research proposes implementing G1 through a combination of (i) structural encapsulation, (ii) explicit dependency declaration, and (iii) automated verification:
\begin{itemize}[itemsep=8pt,topsep=2pt]
  \item \emph{Structural encapsulation:} Separate public API packages from internal packages, and restrict visibility so that only the declared API is importable across module boundaries.
  \item \emph{Declarative dependency model:} Maintain a module descriptor that defines which modules are required and which are forbidden, and keep it version-controlled with boundary changes.
  \item \emph{Automated verification:} Fail the build when undeclared cross-module references are detected, and optionally verify event subscriptions and command usage against declared dependencies.
\end{itemize}

\subsection*{Common Failure Modes and Anti-Patterns}
The following failure modes are frequently observed in codebases that lack explicit boundary enforcement. Each anti-pattern weakens modular isolation and increases the cost of future architectural change. The first five patterns address structural violations at the code level; the remaining five address design-level decisions that erode modularity before a single import is written.

\subsubsection*{Structural Anti-Patterns}

\begin{itemize}[itemsep=8pt,topsep=2pt]
  \item \emph{Convenience-Driven Imports:} Developers import internal classes from another module because the path is shorter or the type is already available. Over time, these imports create a web of hidden coupling that boundary checks cannot detect if enforcement is absent~\cite{parnas1972informationhiding}. This anti-pattern is captured by an increase in $C_{\mathrm{leak}}$.

  \item \emph{Shared Utility Creep:} A \texttt{shared/} or \texttt{common/} package grows to include domain-specific logic that belongs inside a bounded context~\cite{martin2012clean}. Modules become coupled through this shared layer rather than through explicit contracts. This is reflected in rising $C_{\mathrm{undecl}}$ when shared utilities reference module internals.

  \item \emph{Implicit Wiring via Framework Magic:} Dependency injection containers, auto-configuration, or classpath scanning silently wire modules together without any declared dependency. Boundary checks based on import analysis miss these couplings entirely. This failure mode surfaces through declining $P_{\mathrm{iso}}$ when module isolation tests fail due to undeclared runtime dependencies.

  \item \emph{Event Handlers Registered Outside the Composition Root:} When event subscriptions are scattered across module initializers rather than centralized in a single wiring location, the integration surface becomes invisible to architectural review. This increases $C_{\mathrm{event}}$ and makes the system's collaboration topology difficult to audit.

  \item \emph{Boundary Enforcement Treated as Optional:} When boundary verification gates are not part of the mandatory CI pipeline, violations accumulate silently. Teams discover the erosion only when a refactoring or extraction attempt reveals that modules are far more coupled than the architecture documentation suggests~\cite{thoughtworks2017fitnessfunction}. Quality is a deliberate choice; without enforcement, the cost of accumulated violations compounds quietly until a refactoring or extraction attempt reveals the true state of the architecture.
\end{itemize}

\subsubsection*{Design-Level Anti-Patterns}

\begin{itemize}[itemsep=8pt,topsep=2pt]
  \item \emph{Extreme Granularity:} Teams slice the system into excessively narrow domains (StockCheck, ReservationHold, WarehouseAllocation, StockReplenishment) instead of grouping them under a cohesive bounded context (Inventory). Similarly, splitting User, Authentication, Authorization, and ProfileManagement into separate modules when they all belong to a single Identity context creates artificial boundaries that generate coupling without gaining isolation. Each micro-domain cannot fulfill a business workflow independently, forcing constant cross-module calls for routine operations like reserving stock during order placement or authenticating a user session. The result is high coupling across many small modules that share the same data and the same transaction boundaries, effectively recreating distributed complexity inside the monolith~\cite{dragoni2017microservices, fowler2014}. G1 requires that module boundaries align with bounded contexts~\cite{evans2003ddd} large enough to complete a workflow end-to-end and small enough to be owned by a single team.

  \item \emph{Speculative Generality:} The codebase accumulates extension points, abstract factories, strategy patterns, hooks, and metaprogramming constructs designed for hypothetical future requirements that may never materialize. Each speculative abstraction adds navigational complexity and implicit coupling: consumers depend on interfaces whose contracts are shaped by imagined use cases rather than observed needs. This anti-pattern directly contradicts the progressive scalability philosophy (G3), which advocates for proportional intervention driven by evidence, not by speculation. The YAGNI principle~\cite{extremeProgramming} applies at the architectural level: if a pattern is not required by a current bounded context interaction or a measured scaling bottleneck, it should not exist in the codebase. Removing speculative abstractions often improves both cohesion (fewer unused symbols per module) and coupling (fewer unnecessary interfaces crossing boundaries).

  \item \emph{Leaky Abstractions in Public Contracts:} A module exposes DTOs or event payloads that mirror its internal database schema rather than its domain model~\cite{fowler2002}. Downstream consumers couple to storage-level details: column names, join structures, nullable fields that reflect persistence trade-offs rather than business semantics. When the originating module refactors its schema, all consumers break, even though no business rule changed. G1 requires that public contracts reflect domain intent; anti-corruption layers (formalized in G4) provide the translation boundary that prevents internal models from leaking outward~\cite{evans2003ddd}. This anti-pattern is detectable when event or DTO field names match database column names verbatim.

  \item \emph{Circular Dependencies Between Modules:} Module A depends on Module B, which depends on Module A, often through indirect paths that span three or more modules. Circular dependencies make independent testing, reasoning, and extraction impossible: changing any module in the cycle requires understanding all of them~\cite{martin2012clean, yourdon1979structured}. Cycles typically signal that bounded contexts need redrawing or that a shared contract (event, value object) should be extracted into a common library. Dependency graph tooling can visualize these cycles immediately, but prevention requires encoding the allowed dependency direction as an automated rule. G1 treats any circular dependency as a blocking violation.

  \item \emph{Test Coupling Across Boundaries:} Test code in Module A directly instantiates domain objects from Module B to build fixtures or assert on internal state. This creates invisible coupling that does not appear in production imports but makes modules inseparable in practice: a refactoring of Module B's internal entities breaks Module A's test suite. Test boundaries should mirror production boundaries. Modules should provide test factories or fixture builders as part of their public test surface, and tests in other modules should depend only on those published utilities, never on internal constructors or repository implementations.
\end{itemize}

\subsubsection*{SOLID as Boundary Discipline}

\noindent
These anti-patterns share a common root: they treat modularity as an organizational convenience rather than as an enforceable architectural property. The SOLID principles, when applied with discipline, address many of these failure modes directly. The Single Responsibility Principle prevents god modules and extreme granularity by requiring that each module encapsulates one cohesive business capability. The Open-Closed Principle, properly understood, means modules are open for extension through published contracts (events, handlers) rather than through speculative abstractions. The Dependency Inversion Principle ensures that modules depend on stable interfaces rather than on volatile internals from other bounded contexts~\cite{martin2012clean}. The misapplication of SOLID, however, is itself a common failure mode: teams interpret these principles as mandates for complex abstractions (deep inheritance hierarchies, excessive interfaces, premature generalization) rather than as guidelines for simpler, more stable boundaries. In a modular monolith, SOLID serves boundary discipline, not architectural ornamentation.

\subsubsection*{The Enforcement Gap}

\noindent
Recognizing anti-patterns and understanding SOLID principles is necessary but not sufficient. Most of the failure modes described above are well known by the software industry; experienced engineers recognize them on sight during code reviews and design discussions. Yet recognition alone does not prevent them. The gap between conceptual knowledge and daily practice persists because these principles are rarely operationalized as measurable, automated constraints~\cite{fairbanks2010justenough}. They exist as shared understanding in the team's collective memory, not as executable checks in the CI pipeline.

This gap compounds with growth. A single convenience import is harmless; hundreds of locally reasonable shortcuts across months of fast-paced delivery by multiple engineers and teams produce systemic architectural drift that no amount of documentation or periodic review can reverse. By the time the drift becomes visible, typically during an extraction attempt or a major refactoring, the cost of correction dwarfs the cost of prevention.

The metrics and enforcement gates introduced in this guideline (and extended throughout G2 through G6) represent a deliberate attempt to close this gap: translating what engineers already know into what the build system can verify on every commit.

\subsection*{Metrics and Verification}

The metrics below operationalize modular boundary enforcement as measurable, automated constraints. Each metric follows a three-layer structure: a plain-language description of what it captures and why it matters, a formal definition that enables unambiguous implementation, and an enforcement threshold that determines whether the boundary gate passes or fails. Together, they translate the principles discussed in the preceding sections into executable verification rules.

\medskip
\noindent
\emph{Notation.} Let $M$ be the set of bounded-context modules. Let $R$ be the multiset of observed cross-module references, including static imports, dependency injection wiring, and event handler registrations. For a pair of modules $(A, B)$, let $\operatorname{refs}(A \to B) \subseteq R$ denote the references originating in $A$ that target symbols in $B$. Let $D \subseteq M \times M$ be the set of declared allowed dependencies (\emph{requires}) and $F \subseteq M \times M$ be the set of explicitly forbidden dependencies (\emph{forbids}), both defined in the module descriptor. Let $\operatorname{pub}(B)$ denote the set of symbols in module $B$'s declared public API surface.

\begin{itemize}[itemsep=8pt,topsep=2pt]
  \item \textbf{Undeclared Dependency Reference Count} ($C_{\mathrm{undecl}}$). \\
  A reference from module $A$ to a symbol in module $B$ is \emph{undeclared} when the dependency $A \to B$ does not appear in the module descriptor. Undeclared references represent invisible coupling: they exist in the codebase but are not subject to architectural review. Every undeclared reference is a potential extraction blocker, because it will only surface when the modules are separated~\cite{deLauretis2019from}.
  \[
    C_{\mathrm{undecl}} = \sum_{A \neq B} \left|\left\{ r \in \operatorname{refs}(A \to B) : (A, B) \notin D \right\}\right|
  \]
  \emph{Threshold:} $C_{\mathrm{undecl}} = 0$. Any undeclared reference fails the boundary gate.

  \item \textbf{Forbidden Dependency Reference Count} ($C_{\mathrm{forbid}}$). \\
  Some module pairs are explicitly forbidden from depending on each other, typically to prevent circular dependencies or to enforce layering constraints~\cite{martin2012clean}. A forbidden reference is one where the dependency $A \to B$ appears in the \emph{forbids} set. Unlike undeclared references (which may be oversight), forbidden references represent known architectural violations that have been explicitly prohibited.
  \[
    C_{\mathrm{forbid}} = \sum_{A \neq B} \left|\left\{ r \in \operatorname{refs}(A \to B) : (A, B) \in F \right\}\right|
  \]
  \emph{Threshold:} $C_{\mathrm{forbid}} = 0$. Any forbidden reference fails the boundary gate.

  \item \textbf{Encapsulation Leakage Count} ($C_{\mathrm{leak}}$). \\
  Encapsulation leakage occurs when a module consumes internal symbols (classes, functions, types, resources) from another module rather than using its declared public API surface. This violates the information hiding principle~\cite{parnas1972informationhiding}: consumers become coupled to implementation details that the provider should be free to change. Even when the dependency $A \to B$ is declared, references that bypass the public surface create fragile coupling that increases the blast radius of internal refactoring.
  \[
    C_{\mathrm{leak}} = \sum_{A \neq B} \left|\left\{ r \in \operatorname{refs}(A \to B) : \operatorname{target}(r) \notin \operatorname{pub}(B) \right\}\right|
  \]
  \emph{Threshold:} $C_{\mathrm{leak}} = 0$. All cross-module references must target the provider's public API surface.

  \item \textbf{Module Isolation Test Pass Rate} ($P_{\mathrm{iso}}$). \\
  Static analysis can detect import-level violations, but some forms of coupling are only observable at runtime: implicit wiring through dependency injection containers, service locator patterns, or transitive module loading. The isolation test pass rate captures these hidden dependencies by executing each module's test suite with only the module and its declared dependencies available~\cite{fairbanks2010justenough}. A failing isolation test indicates that the module depends on runtime context from an undeclared module, even when its static imports appear compliant.
  \[
    P_{\mathrm{iso}} = \frac{|T_{\mathrm{pass}}|}{|T_{\mathrm{iso}}|}
  \]
  where $T_{\mathrm{iso}}$ is the set of module-scoped isolation tests and $T_{\mathrm{pass}} \subseteq T_{\mathrm{iso}}$ is the subset that passes.\\
  \emph{Threshold:} $P_{\mathrm{iso}} = 100\%$. Any isolation test failure fails the boundary gate.

  \item \textbf{Event Subscription Boundary Violations} ($C_{\mathrm{event}}$). \\
  In systems that use event-driven integration, a module may consume events from another module without declaring that dependency. This creates coupling that is invisible to static import analysis because the subscription is typically registered at runtime through the event bus infrastructure. Event subscription violations are particularly insidious because they couple modules through data flow rather than code structure, making the dependency harder to detect during code review~\cite{richardson2018microservices}.
  \[
    C_{\mathrm{event}} = \left|\left\{ (A, B) \in H : (A, B) \notin D \right\}\right|
  \]
  where $H$ is the set of $(subscriber, publisher)$ pairs derived from event handler registrations.\\
  \emph{Threshold:} $C_{\mathrm{event}} = 0$. Every event subscription must correspond to a declared dependency.
\end{itemize}

\medskip
\noindent
\textbf{Compliance summary.} G1 boundary compliance holds when all five metrics satisfy their thresholds simultaneously:
\[
  C_{\mathrm{undecl}} = 0 \;\wedge\; C_{\mathrm{forbid}} = 0 \;\wedge\; C_{\mathrm{leak}} = 0 \;\wedge\; P_{\mathrm{iso}} = 100\% \;\wedge\; C_{\mathrm{event}} = 0
\]
This compound condition is evaluated on every commit by the boundary verification gate. A violation of any single metric blocks the commit, ensuring that boundary erosion is detected at the point of introduction rather than during a downstream extraction attempt. The metrics are designed to be composable: G2 extends them with maintainability dimensions, G3 with scalability signals, and G4 with extraction readiness indicators.

\subsection*{Documentation Guidelines}
\begin{itemize}[itemsep=8pt,topsep=2pt]
  \item \emph{Module Descriptor:}
    Maintain a machine-readable descriptor (YAML, annotation, or code) that centralizes \emph{requires} and \emph{forbids} entries for each module.
  \item \emph{Change Log:}
    Whenever a boundary is added, removed, or modified, update the descriptor with version and author metadata.
\end{itemize}

\subsection*{Tooling Capabilities Checklist}
Any open-source or proprietary tool used to enforce modular boundaries should support:
\begin{itemize}[itemsep=8pt,topsep=2pt]
  \item \emph{Module Discovery:} Automatically identify modules via conventions (for example, module folders, annotations) or explicit configuration.
  \item \emph{Boundary Verification:} Perform automated checks during build/test to detect undeclared cross-module references and fail on violations.
  \item \emph{Event-Driven Enforcement:} Track published events and subscribers, enforcing that only modules with declared subscriptions handle specific events.
  \item \emph{Isolated Testing:} Allow tests to load only a given module (and its declared dependencies), failing early if the module tries to wire code from undeclared modules.
  \item \emph{Documentation Artifacts:} Generate up-to-date artifacts or reports for inclusion in architecture documentation or CI/CD feedback.
  \item \emph{Runtime Validation (Optional):} Optionally perform runtime checks to catch dynamic boundary violations (for example, reflection) that compile-time checks might miss.
\end{itemize}

\subsection*{Literature Support Commentary}
The foundational argument for modular boundaries rests on the principle that information hiding, rather than functional decomposition, should determine module structure~\cite{parnas1972informationhiding}. This principle remains the theoretical anchor for G1: modules in a modular monolith must encapsulate implementation details behind stable interfaces, and cross-module access must be mediated through declared contracts rather than direct knowledge of internals.

The systematic literature review conducted in Chapter~3 reveals that modularity is widely acknowledged as a prerequisite for sustainable architecture, yet few works operationalize it as an enforceable property. A survey of 63 studies on monolith decomposition shows that most approaches focus on \emph{identifying} module boundaries through clustering, dependency analysis, or domain modeling, but stop short of prescribing mechanisms to \emph{enforce} those boundaries once established~\cite{abgaz2023decomposition}. The gap between boundary identification and boundary enforcement is precisely what G1 addresses.

Several SLR-included works provide converging evidence for the importance of explicit modular structure. The ``sliceable monolith'' concept demonstrates that a monolith designed with clean module boundaries can be progressively decomposed into services without a rewrite, validating the premise that boundary discipline must precede extraction~\cite{montesi2021sliceable}. At the infrastructure level, component boundaries enforced at the programming model itself, with deployment topology deferred to a later decision, reinforce the principle that modularity is a build-time property, not a deployment-time afterthought~\cite{ghemawat2023towards}. Systematic analysis of factors influencing modulith adoption identifies ``module boundary definition'' and ``dependency management'' as two of the top five decision drivers over microservices~\cite{prakash2024systematic}.

The coupling and cohesion dimensions that G1 operationalizes through metrics ($C_{\mathrm{leak}}$, $C_{\mathrm{undecl}}$, $C_{\mathrm{forbid}}$, $P_{\mathrm{iso}}$) are well grounded in the decomposition literature. Modernization roadmaps position coupling analysis as the first diagnostic step before any migration decision, treating boundary enforcement as a precondition for all subsequent architectural evolution~\cite{wolfart2021modernizing}. Empirical evidence from migration attempts confirms that monolithic systems fail during extraction not because of inherent architectural limitations but because undeclared dependencies create invisible coupling that only surfaces under separation pressure~\cite{deLauretis2019from}. Trend analyses of modular monolith adoption reinforce this finding, noting that the architecture is driven primarily by the need to control internal coupling before it becomes external complexity~\cite{tsechelidis2023modular}.

The modular monolith is increasingly recognized as a deliberate architectural choice for cloud environments rather than a transitional compromise, with enforceable module isolation identified as the distinguishing characteristic that separates a well-structured monolith from a traditional one~\cite{su2024modular}. Many systems adopt microservices prematurely and would benefit from enforced modularity within a single deployment unit~\cite{gravanis2021dont}, a position that directly supports G1's emphasis on boundary discipline as a first-order concern.

Industry experience reports complement these academic findings. Large-scale monoliths restructured around enforced component boundaries have demonstrated sustained development velocity across hundreds of engineers~\cite{shopify2020monolith, shopify2022}, and legacy system rewrites confirm that automated boundary enforcement is the decisive factor in controlling complexity~\cite{jovanovic2024rewriting}. These practitioner accounts validate the academic consensus: modularity without enforcement degrades under delivery pressure, and the cost of retroactive boundary repair far exceeds the cost of proactive boundary discipline.

\pagebreak
\section{G1 Applied: The Modular Tiny Store Example}
\label{sec:g1-demo-tiny-store}

This section operationalizes Guideline G1 (Enforce Modular Boundaries) using Tiny Store, a small modular monolith maintained as an executable reference for this dissertation.\footnote{\url{https://github.com/maurcarvalho/tiny-store}}
The objective is to show how G1 is applied as an engineering practice, not only as an architectural principle. In Tiny Store, modularity is encoded in the repository structure, integration is wired in a visible composition root, and boundary erosion is surfaced as a failing check. The tutorial therefore connects the guideline to concrete actions: introduce a controlled violation, observe a crisp failure signal, trace it to an unauthorized dependency, and repair the system by restoring an explicit contract between bounded contexts.

The tutorial is written from the perspective of an engineer evolving a monolithic application that contains multiple business capabilities. The goal is to keep bounded contexts isolated, to ensure that any cross-module dependency is intentional and reviewable, and to prevent accidental coupling from accumulating into a refactoring bottleneck.

Two complementary feedback loops are used throughout the steps. The first is \texttt{npm run test:boundary}, which validates structural rules and fails when a module imports
forbidden internals or bypasses the public surface of another context. The second is \texttt{npm run test:integration}, which exercises cross-module behavior end-to-end and confirms that the system remains correct after boundaries are tightened or contracts are introduced. Together, these targets support a workflow that is both practical and repeatable: make a change, observe the result immediately, and keep architectural integrity measurable as the system evolves.

\subsection*{Reader map}
This tutorial is designed to be completed in a single sitting. It assumes you can run the repository's boundary and integration targets locally, and it keeps the steps intentionally hands-on. You will first trigger a boundary failure on demand, then locate the exact import or export that caused the violation, and finally fix it by introducing an explicit modular contract rather than importing another context's internals. The expected time investment is 20--30 minutes, and the outcome is a concrete, reproducible ability to detect and remediate boundary erosion using the same mechanisms that can be embedded into a continuous integration pipeline.

\subsection*{Repository Orientation}
Tiny Store is the reference codebase used in this dissertation to ground architectural claims in an executable artifact. Its structure is designed to make modularity observable: boundaries are explicit in the directory layout, integration points are concentrated in a few predictable places, and the allowed dependency direction can be verified through automated checks.

The repository is an Nx monorepo: a single workspace that contains multiple projects (applications and libraries) managed under a shared toolchain and an inspectable dependency graph.\footnote{\url{https://nx.dev/concepts/monorepos}}
Deployable applications live under \texttt{apps/}, while reusable libraries live under \texttt{libs/}. This separation encodes a core rule of the modular monolith: composition roots are allowed to wire dependencies, while modules remain cohesive units that expose controlled integration surfaces.

The system's HTTP boundary is the \texttt{apps/api/} project, implemented with Next.js (App Router).
REST endpoints under \texttt{apps/api/src/app/api/} act as thin adapters that translate requests into application operations. The same project also hosts shared runtime wiring under
\texttt{apps/api/src/app/lib/}, so the API becomes the main composition root that assembles bounded contexts and connects infrastructure such as persistence and the event bus.

Cross-module integration is intentionally made visible. Listener subscription wiring is centralized in \texttt{apps/api/src/app/lib/register-listeners.ts}, which serves as an auditable map of event choreography: which events are subscribed to, which handlers react, and which dependencies exist at the system level. Centralizing subscriptions avoids hidden side effects (for example, listeners registered implicitly during import time) and makes integration decisions reviewable and testable.

Initially, domain behavior was divided into four bounded contexts under \texttt{libs/modules/}: \texttt{orders}, \texttt{inventory}, \texttt{payments}, and \texttt{shipments}. Each context is an Nx library structured around three concerns. The \texttt{domain/} subtree holds aggregates, entities, value objects, domain events, and repository abstractions. The \texttt{features/} subtree holds application use cases organized as vertical slices. The \texttt{listeners/} subtree reacts to published
events and invokes local features, enabling collaboration without direct access to another context's internals.

Modules are consumed through a deliberate public API surface. Each bounded context exposes an entrypoint, typically \texttt{modules/<context>/src/index.ts}.
This entrypoint is the module's contract: it re-exports only approved symbols (handlers, listener factories, public types, event contracts) and keeps domain internals private. As a result, other projects import capabilities through stable module-level paths (for example,
\texttt{@tiny-store/modules-orders}) while boundary discipline remains enforceable.

The project makes event-driven collaboration the primary cross-module trace. Instead of
``class-to-class'' dependencies, the relevant path is ``event $\rightarrow$ listener $\rightarrow$ feature.'' Orders emits domain events, Inventory reacts to reserve stock, and subsequent events drive Payments and Shipments. This choreography is expressed in each context's \texttt{domain/events/}, implemented by \texttt{listeners/}, and wired in the composition root via \texttt{register-listeners.ts}.

\captionsetup{justification=raggedright,singlelinecheck=false}

\begin{figure}[H]
  \centering
  \includegraphics[width=\linewidth]{Cap4/guidelines/order-events-lifecycle.png}
  \caption{Lifecycle of order-related events across bounded contexts.}
  \label{fig:order-events-lifecycle}

  \vspace{0.5em}
  \begin{minipage}{0.95\linewidth}
    \footnotesize
    \textbf{Statuses description:}
    \begin{description}[leftmargin=!,labelwidth=3.2cm]
      \item[\texttt{PENDING}] Order created, awaiting inventory check
      \item[\texttt{CONFIRMED}] Inventory reserved, ready for payment
      \item[\texttt{REJECTED}] Insufficient stock
      \item[\texttt{PAID}] Payment successful
      \item[\texttt{PAYMENT\_FAILED}] Payment declined
      \item[\texttt{SHIPPED}] Shipment created and dispatched
      \item[\texttt{CANCELLED}] User cancelled order
    \end{description}
  \end{minipage}
\end{figure}

\pagebreak

Shared code is intentionally constrained under \texttt{libs/shared/}. The \texttt{domain/} library provides domain-neutral primitives, while \texttt{infrastructure/} provides reusable mechanisms such as the in-memory event bus and persistence utilities. This split reduces accidental coupling: domain meaning stays inside bounded contexts, and shared libraries remain a small set of stable building blocks rather than a catch-all dependency hub.

\begin{figure}[H]
  \centering
  \includegraphics[width=\linewidth]{Cap4/guidelines/repo-orientation-diagram.png}
  \caption{Repository-level orientation of the Tiny Store monorepo.}
  \label{fig:repo-orientation-diagram}
\end{figure}

Architecture is enforced as executable checks. The \texttt{npm run test:boundary} target validates module dependency rules and detects coupling regressions, while \texttt{npm run test:integration} exercises cross-module flows end-to-end. Together, they provide fast feedback on both structural correctness and runtime behavior.

A practical reading order follows the enforced dependency direction: begin at \texttt{apps/api/} to see system assembly, then
inspect \texttt{register-listeners.ts} to identify cross-context collaboration points. Next, enter a bounded context through its \texttt{src/index.ts} public surface and trace inward from
\texttt{features/} into \texttt{domain/}. When behavior crosses contexts, follow the published events into \texttt{listeners/} and then into the next context's \texttt{features/}. This navigation strategy reflects the architectural intent: explicit contracts, visible integration, and boundaries that remain testable as the system scales.

This repository orientation establishes the concrete elements that G1 relies on: bounded contexts exposed through explicit entrypoints, cross-context collaboration expressed as event-driven contracts, and integration wiring centralized in the composition root. With this map in place, the tutorial can move from structure to action. The steps below apply G1 using Tiny Store as an executable reference.
Each step states the intent and the expected signal, and when applicable it includes a runnable snippet that reproduces a boundary failure, pinpoints the violating dependency, and validates the
fix through the same automated checks that enforce modular boundaries during day-to-day development.

\pagebreak
\subsection*{Tutorial: Step-by-Step Application}
The steps below apply G1 using Tiny Store as an executable reference. Each step states the intent and the expected signal, and when applicable it includes a runnable snippet.

\subsubsection*{Steps}
\begin{itemize}[itemsep=8pt,topsep=4pt]

  \item \emph{Step 0: Establish a Clean Baseline:}
  Confirm that boundary enforcement is active before introducing controlled violations.
  Run the baseline checks, and verify that all targets pass.

  \begin{lstlisting}[language=bash,caption={Baseline checks for G1},label={lst:g1-baseline}]
npm install
npm test
npm run test:boundary
npm run test:integration
  \end{lstlisting}

\item \emph{Step 1: Confirm Module Discovery is Unambiguous:}
Verify that bounded contexts are mechanically discoverable by path conventions, enabling static boundary checks.
In Tiny Store, bounded contexts live under \texttt{libs/modules/<context>/}, and shared primitives live under \texttt{libs/shared/}.

\begin{itemize}[itemsep=8pt,topsep=2pt]
  \item \DoMark\ Do: treat \texttt{libs/modules/<context>/} as the outer boundary for G1.
  \item \DontMark\ Don't: create ad-hoc bounded contexts inside \texttt{libs/shared/} without enforcement.
\end{itemize}

\item \emph{Step 2: Treat Package-by-Feature as Internal Organization Only:}
Confirm that feature slices improve cohesion inside a module while the outer boundary remains
contract-based. Feature code (for example \texttt{src/features/}) may depend on \texttt{domain/} within
the same module, but must not import other modules' features or domain internals.

\begin{itemize}[itemsep=8pt,topsep=2pt]
  \item \DoMark\ Do: allow \texttt{features/} $\rightarrow$ \texttt{domain/} dependencies inside the same module.
  \item \DontMark\ Don't: allow module $A$ feature code to import module $B$ feature or domain internals.
\end{itemize}



\pagebreak
  \item \emph{Step 3: Separate Public Surface from Internal Components:}
  Ensure cross-module usage occurs only through module entrypoints (for example \texttt{@tiny-store/modules-orders}), so internals cannot leak by import convenience.

  \begin{lstlisting}[language=TypeScript,caption={Public entrypoint import (allowed)},label={lst:g1-do-public-import}]
/**
 * ✅ DO: import the module via its public entrypoint.
 * The public surface should expose handlers, ports, and event contracts,
 * not domain entities or repositories.
 */
import { PlaceOrderHandler } from '@tiny-store/modules-orders';
  \end{lstlisting}

The example above is correct because it imports a capability that the Orders module explicitly exposes as part of its contract. The rest of the system depends on what Orders \emph{does} (a use case handler), not on how Orders \emph{implements} its domain model. This is the preferred dependency shape: module-to-module dependencies point to stable entrypoints, and the set of exposed symbols remains small enough to be audited as the system grows.

  \begin{lstlisting}[language=TypeScript,caption={Cross-module import of internals (blocked)},label={lst:g1-dont-internals-import}]
/**
 * ❌ DON'T: entities and repositories should remain internal to the module.
 */
import { Order } from '@tiny-store/modules-orders';
// internal entity
import { OrderRepository } from '@tiny-store/modules-orders';
// internal repository
  \end{lstlisting}

The code above is incorrect because it couples other contexts to Orders' implementation details.
Other modules should not construct, persist, or reason about Orders via internal entities or repositories, even if the import path appears ``official.'' Reactions to order state changes should flow through event contracts and listeners, while requests to Orders should use a use case handler exported by the public surface. When functionality is genuinely cross-cutting, promote it to \texttt{libs/shared/} as a domain-neutral primitive instead of importing or duplicating Orders' internals. This preserves module autonomy, keeps invariants local, and prevents boundary checks from being eroded by convenience imports.

\pagebreak
  \item \emph{Step 4: Encode Explicit Declarations (Descriptor Equivalent):}
  Keep dependency rules explicit and reviewable by expressing \emph{requires} and \emph{forbids} in a single, executable source of truth (in Tiny Store, the boundary test suite plays this role).

  \begin{lstlisting}[language=TypeScript,caption={Example code-based boundary descriptor (illustrative)},label={lst:g1-descriptor}]
/**
 * Example only: keep a single source of truth for module boundaries.
 * This can live near libs/shared/testing/src/module-boundaries.ts
 * and be imported by module-boundary.spec.ts.
 */
export const moduleBoundaries = {
  orders: {
    requires: ['shared-domain', 'shared-infrastructure'],
    forbids: ['inventory', 'payments', 'shipments'],
  },
  inventory: {
    requires: ['shared-domain', 'shared-infrastructure'],
    forbids: ['orders', 'payments', 'shipments'],
  },
} as const;
  \end{lstlisting}

  \item \emph{Step 5: Centralize Cross-Module Wiring in the Composition Root:}
  Ensure cross-module collaboration is auditable by keeping listener subscription wiring in the API composition root, rather than inside module internals.

\begin{lstlisting}[language=TypeScript,caption={Centralized wiring in the composition root (\texttt{apps/api/src/app/lib/register-listeners.ts})},label={lst:g1-do-wiring}]
/**
 * ✅ DO: keep subscriptions centralized in the composition root
 * (apps/api/src/app/lib/register-listeners.ts) so cross-module wiring is auditable.

 * The sub binds an event name (contract) to a handler (reaction).
 */
import { EventBus } from '@tiny-store/shared-infrastructure';
import { OrderPlacedListener } from '@tiny-store/modules-inventory';

const eventBus = EventBus.getInstance();
eventBus.subscribe('OrderPlaced', (event) => {
  return new OrderPlacedListener().handle(event);
});
\end{lstlisting}


\begin{lstlisting}[language=TypeScript,caption={Hidden wiring inside a module (avoid)},label={lst:g1-dont-hidden-wiring}]
/**
 * ❌ DON'T: wiring inside a module makes dependencies implicit and harder to audit.
 * Subscriptions should be registered in the composition root instead.
 */
EventBus.getInstance().subscribe('OrderPlaced', handler);
\end{lstlisting}

\item \emph{Step 6: Enforce Boundary Verification as a First-Class Gate:}
Boundary rules only protect the architecture if they run continuously. This step treats boundary verification as a mandatory gate in the local workflow and in CI, so boundary erosion is detected before it reaches runtime. In Tiny Store, the gate is \texttt{npm run test:boundary}: it encodes the allowed dependency direction between domains and fails the build whenever a module bypasses a public surface, imports forbidden internals, or introduces an unauthorized cross-context dependency.
The key idea is to make architectural integrity measurable and non-optional, using the same feedback loop that already exists for unit and integration tests.

\begin{lstlisting}[language=bash,caption={Boundary verification gate},label={lst:g1-boundary-gate}]
npm run test:boundary

❌ Boundary violation detected

Source project:   libs/modules/orders
Forbidden import: libs/modules/inventory/src/domain/Product.ts
Importing file:   libs/modules/orders/src/features/place-order/use-case.ts

Rule: Modules must import other modules only via their public entrypoint
      (e.g., @tiny-store/modules-inventory), not internal domain files.

Fix:  Replace internal import with an explicit contract:
      - consume a public handler, or
      - react via an event + listener, or
      - move truly shared primitives to libs/shared/.
\end{lstlisting}

The expected signal is binary: the gate either passes (no violations) or fails with a report that pinpoints the violating dependency.

In addition to the tooling-level gate, it is useful to have a focused automated test that asserts the intended public surface. The objective is not to ``test architecture'' by runtime imports alone, but to provide a readable specification of what must and must not be available through each module's entry-point. The example below checks that internal entities are not exposed, while public handlers are available. This test is complementary to \texttt{test:boundary}: it documents expectations and protects against accidental re-exports in \texttt{src/index.ts}.

\begin{lstlisting}[language=TypeScript,caption={Public surface test: internals are not exported, handlers are},label={lst:g1-boundary-spec}]
/**
 * libs/shared/testing/src/module-boundary.spec.ts
 *
 * This test asserts the module public surface (entrypoint exports).
 * It complements test:boundary by preventing accidental re-exports of internals.
 */
describe('Module Public Surface', () => {
  it('does not expose Inventory internals via the module entrypoint', async () => {
    const inventory = await import('@tiny-store/modules-inventory');

    // Internal domain types must NOT be part of the public API surface.
    expect((inventory as any).Product).toBeUndefined();
    expect((inventory as any).InventoryRepository).toBeUndefined();
  });

  it('exposes Orders public handlers via the module entrypoint', async () => {
    const orders = await import('@tiny-store/modules-orders');

    // Public capabilities are allowed and expected.
    expect((orders as any).PlaceOrderHandler).toBeDefined();
    expect((orders as any).GetOrderHandler).toBeDefined();
  });
});
\end{lstlisting}

When this gate is treated as first-class, the architectural rules stop being informal conventions and become enforced constraints. In practice, the boundary policy can be summarized as follows: external modules must not access another context's entities, repositories, or internal services; they may depend on public handlers, event contracts, and listener wiring through the composition root; and they may reuse domain-neutral primitives from \texttt{libs/shared/}. This is the mechanism that keeps G1 enforceable as the codebase scales.

  \item \emph{Step 7: Add Module Isolation Checks to Detect Hidden Wiring:}
  Detect coupling that does not appear as imports by running module-scoped isolation tests that load a module with only its declared dependencies available.

  \begin{lstlisting}[language=TypeScript,caption={Illustrative module isolation test},label={lst:g1-isolation}]
/**
 * Example only: the test should fail if the Orders module tries to
 * access undeclared modules during wiring or handler execution.
 */
describe('Orders module isolation', () => {
  it('loads with declared dependencies only', async () => {
    const module = await loadModule('orders', {
      allowed: ['shared-domain', 'shared-infrastructure'],
    });
    expect(module).toBeDefined();
  });
});
  \end{lstlisting}

\end{itemize}

\subsection*{Exercise Walkthrough: Controlled Violations and Signals}
The exercises below intentionally break modular boundaries to demonstrate that enforcement is
active and to make failure signals actionable. Each exercise introduces a single, controlled breach, runs the same automated gates used in day-to-day development, and observes the resulting signal. This structure serves two purposes: it confirms that the boundary rules are not merely documented, and it trains the reader to diagnose violations quickly by linking a concrete change to a predictable failure mode.

To keep the summary compact, the table uses a lightweight metric notation. $C_{\bullet}$ denotes a \emph{count} of violations or disallowed references (higher is worse), while $P_{\bullet}$ denotes a \emph{pass rate} (higher is better). In particular, $C_{\mathrm{leak}}$ counts public-surface leaks (internal symbols exposed or consumed externally), $C_{\mathrm{undecl}}$ counts undeclared cross-module references, $C_{\mathrm{forbid}}$ counts references that violate an explicit forbidden
dependency rule, $P_{\mathrm{iso}}$ captures the isolation pass rate when module-scoped tests are executed under declared dependencies only, and $C_{\mathrm{event}}$ counts boundary violations in event subscription and handling.

\subsubsection*{Exercise summary}
\small
\noindent
\begin{tabularx}{\linewidth}{p{0.06\linewidth} X p{0.24\linewidth} p{0.20\linewidth}}
\textbf{Ex.} & \textbf{What you change} & \textbf{Run} & \textbf{Signal / metric} \\
0 & Establish baseline & \texttt{test:boundary}\newline\texttt{test:integration} & pass (baseline) \\
1 & Export internal symbols (leak) & \texttt{test:boundary} & fail, $C_{\mathrm{leak}}\uparrow$ \\
2 & Add direct cross-module import & \texttt{test:boundary} & fail (or add rule), $C_{\mathrm{undecl}}\uparrow$ / $C_{\mathrm{forbid}}\uparrow$ \\
3 & Subscribe inside module (hidden wiring) & \texttt{test:boundary}\newline\texttt{test:integration} & fail (rule/iso), $P_{\mathrm{iso}}\downarrow$ / $C_{\mathrm{event}}\uparrow$ \\
\end{tabularx}
\normalsize

\subsubsection*{Exercises}
\begin{itemize}[itemsep=10pt,topsep=4pt]

  \item \emph{Exercise 0: Confirm the Baseline:}
  Re-run Step 0, and confirm that all checks pass.

  \item \emph{Exercise 1: Create an Encapsulation Leak by Exporting an Internal Symbol:}
  Demonstrate that entities and repositories must not be exposed through module entrypoints. Introduce the violation by exporting internal symbols from the Orders module entry-point (for example \texttt{libs/modules/orders/src/index.ts}).

  \begin{lstlisting}[language=TypeScript,caption={Violation: exporting internal symbols},label={lst:g1-ex1-leak}]
/**
 * ❌ VIOLATION: exporting internal domain symbols leaks encapsulation.
 */
export * from './domain/entities/order';
export * from './domain/repositories/order-repository';
  \end{lstlisting}

Run enforcement.
  \begin{lstlisting}[language=bash,caption={Run boundary enforcement after Exercise 1},label={lst:g1-ex1-run}]
npm run test:boundary
  \end{lstlisting}

  \emph{Expected signal:} a boundary test fails, and $C_{\mathrm{leak}}\uparrow$.

  \emph{Fix:} remove these exports, and expose a contract instead (handler/port/event).

  \item \emph{Exercise 2: Introduce a Direct Cross-Module Import (Undeclared or Forbidden):}
  Demonstrate that bounded contexts must not couple via direct imports for convenience. Introduce the violation by adding a direct import in an Orders feature file under \texttt{libs/modules/orders/src/features/}.

  \begin{lstlisting}[language=TypeScript,caption={Violation: direct cross-module import},label={lst:g1-ex2-import}]
/**
 * ❌ VIOLATION: Orders directly imports Inventory.
 */
import { SomeInventoryHandler } from '@tiny-store/modules-inventory';
  \end{lstlisting}

  Run enforcement.

  \begin{lstlisting}[language=bash,caption={Run boundary enforcement after Exercise 2},label={lst:g1-ex2-run}]
npm run test:boundary
  \end{lstlisting}

  \emph{Expected signal:} a boundary check fails if cross-module imports are constrained by the enforcement suite.
  If it does not fail, treat this as an enforcement coverage gap and extend \texttt{module-boundary.spec.ts} to detect forbidden \texttt{@tiny-store/modules-*} imports from within another module.

  \emph{Metric impact:} $C_{\mathrm{undecl}}\uparrow$ or $C_{\mathrm{forbid}}\uparrow$.

  \emph{Fix (preferred):} replace the direct import with event-driven collaboration (publish \texttt{OrderPlaced}, react in Inventory, publish \texttt{InventoryReserved}).

  \item \emph{Exercise 3: Hide Event Wiring Inside a Module (Implicit Dependency):}
  Demonstrate why subscription wiring must remain centralized and auditable.
  Introduce the violation by placing a subscription call inside a module file (for example under \texttt{libs/modules/<context>/src/listeners/}).

  \begin{lstlisting}[language=TypeScript,caption={Violation: hidden event wiring},label={lst:g1-ex3-hidden-wiring}]
/**
 * ❌ VIOLATION: hidden event wiring inside a module.
 */
EventBus.getInstance().subscribe('OrderPlaced', (e) => this.handle(e));
  \end{lstlisting}


Run enforcement.

 \begin{lstlisting}[language=bash,caption={Run enforcement after Exercise 3},label={lst:g1-ex3-run}]
npm run test:boundary && npm run test:integration

\end{lstlisting}
  \emph{Expected signal:} this may not fail immediately if the current enforcement suite does not scan for subscription calls outside the composition root. In that case, enforce a rule that forbids \texttt{eventBus.subscribe(} usage outside \texttt{apps/api/src/app/lib/register-listeners.ts}, and/or detect it via module isolation tests.

  \emph{Metric impact:} $P_{\mathrm{iso}}\downarrow$ and potentially $C_{\mathrm{event}}\uparrow$.

  \emph{Fix:} move the subscription back to \texttt{register-listeners.ts}.
\end{itemize}

\subsection*{Conclusion of the G1 Implementation}
This section demonstrated that enforcing modular boundaries in a modular monolith is not a matter of documentation or developer discipline alone. In Tiny Store, G1 is implemented as an executable practice: bounded contexts are exposed through explicit entry-points, cross-context collaboration is expressed through contracts (events, handlers, and listener registration), and integration wiring is kept visible in the composition root. When a boundary is violated, the failure signal is immediate and actionable, pointing to the exact dependency that must be removed or formalized.

The walkthrough exercises reinforced the practical distinction between contract-based and convenience-based dependency shapes. The right shape is contract-based: modules depend on other modules through public handlers and event contracts, with subscriptions registered centrally so that integration is reviewable. The wrong shape bypasses these contracts by importing internals, leaking symbols through entry-points, or hiding wiring inside modules, creating architectural debt that turns implementation details into system-wide dependencies.

The boundary verification gate (\texttt{npm run test:boundary}), complemented by integration checks and public-surface assertions, turns modularity into a measurable constraint that scales with the codebase. G1 is not only a guideline but also the foundation that enables progressive scalability by keeping decomposition options open while the system remains a single deployable unit. With boundaries enforced and coupling kept explicit, the next constraint shifts from \emph{whether} modules can remain isolated to \emph{how} they can be evolved safely, motivating Guideline G2.